{"version":3,"file":"index.js","sources":["../src/log.ts","../src/generated/models/mappers.ts","../src/generated/models/parameters.ts","../src/generated/keyVaultClientContext.ts","../src/generated/keyVaultClient.ts","../src/constants.ts","../../keyvault-common/src/challengeBasedAuthenticationPolicy.ts","../../keyvault-common/src/parseKeyvaultIdentifier.ts","../../keyvault-common/src/tracingHelpers.ts","../src/lro/keyVaultSecretPoller.ts","../src/identifier.ts","../src/transformations.ts","../src/lro/delete/operation.ts","../src/lro/delete/poller.ts","../src/lro/recover/operation.ts","../src/lro/recover/poller.ts","../src/secretsModels.ts","../src/index.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createClientLogger } from \"@azure/logger\";\n\n/**\n * The \\@azure/logger configuration for this package.\n */\nexport const logger = createClientLogger(\"keyvault-secrets\");\n","/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport * as coreHttp from \"@azure/core-http\";\n\nexport const SecretSetParameters: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"SecretSetParameters\",\n    modelProperties: {\n      value: {\n        serializedName: \"value\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: { type: { name: \"String\" } }\n        }\n      },\n      contentType: {\n        serializedName: \"contentType\",\n        type: {\n          name: \"String\"\n        }\n      },\n      secretAttributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"SecretAttributes\"\n        }\n      }\n    }\n  }\n};\n\nexport const Attributes: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"Attributes\",\n    modelProperties: {\n      enabled: {\n        serializedName: \"enabled\",\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      notBefore: {\n        serializedName: \"nbf\",\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      expires: {\n        serializedName: \"exp\",\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      created: {\n        serializedName: \"created\",\n        readOnly: true,\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      updated: {\n        serializedName: \"updated\",\n        readOnly: true,\n        type: {\n          name: \"UnixTime\"\n        }\n      }\n    }\n  }\n};\n\nexport const SecretBundle: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"SecretBundle\",\n    modelProperties: {\n      value: {\n        serializedName: \"value\",\n        type: {\n          name: \"String\"\n        }\n      },\n      id: {\n        serializedName: \"id\",\n        type: {\n          name: \"String\"\n        }\n      },\n      contentType: {\n        serializedName: \"contentType\",\n        type: {\n          name: \"String\"\n        }\n      },\n      attributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"SecretAttributes\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: { type: { name: \"String\" } }\n        }\n      },\n      kid: {\n        serializedName: \"kid\",\n        readOnly: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      managed: {\n        serializedName: \"managed\",\n        readOnly: true,\n        type: {\n          name: \"Boolean\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyVaultError: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyVaultError\",\n    modelProperties: {\n      error: {\n        serializedName: \"error\",\n        type: {\n          name: \"Composite\",\n          className: \"ErrorModel\"\n        }\n      }\n    }\n  }\n};\n\nexport const ErrorModel: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"ErrorModel\",\n    modelProperties: {\n      code: {\n        serializedName: \"code\",\n        readOnly: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      message: {\n        serializedName: \"message\",\n        readOnly: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      innerError: {\n        serializedName: \"innererror\",\n        type: {\n          name: \"Composite\",\n          className: \"ErrorModel\"\n        }\n      }\n    }\n  }\n};\n\nexport const SecretUpdateParameters: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"SecretUpdateParameters\",\n    modelProperties: {\n      contentType: {\n        serializedName: \"contentType\",\n        type: {\n          name: \"String\"\n        }\n      },\n      secretAttributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"SecretAttributes\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: { type: { name: \"String\" } }\n        }\n      }\n    }\n  }\n};\n\nexport const SecretListResult: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"SecretListResult\",\n    modelProperties: {\n      value: {\n        serializedName: \"value\",\n        readOnly: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"SecretItem\"\n            }\n          }\n        }\n      },\n      nextLink: {\n        serializedName: \"nextLink\",\n        readOnly: true,\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const SecretItem: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"SecretItem\",\n    modelProperties: {\n      id: {\n        serializedName: \"id\",\n        type: {\n          name: \"String\"\n        }\n      },\n      attributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"SecretAttributes\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: { type: { name: \"String\" } }\n        }\n      },\n      contentType: {\n        serializedName: \"contentType\",\n        type: {\n          name: \"String\"\n        }\n      },\n      managed: {\n        serializedName: \"managed\",\n        readOnly: true,\n        type: {\n          name: \"Boolean\"\n        }\n      }\n    }\n  }\n};\n\nexport const DeletedSecretListResult: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"DeletedSecretListResult\",\n    modelProperties: {\n      value: {\n        serializedName: \"value\",\n        readOnly: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DeletedSecretItem\"\n            }\n          }\n        }\n      },\n      nextLink: {\n        serializedName: \"nextLink\",\n        readOnly: true,\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const BackupSecretResult: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"BackupSecretResult\",\n    modelProperties: {\n      value: {\n        serializedName: \"value\",\n        readOnly: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const SecretRestoreParameters: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"SecretRestoreParameters\",\n    modelProperties: {\n      secretBundleBackup: {\n        serializedName: \"value\",\n        required: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const SecretProperties: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"SecretProperties\",\n    modelProperties: {\n      contentType: {\n        serializedName: \"contentType\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const SecretAttributes: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"SecretAttributes\",\n    modelProperties: {\n      ...Attributes.type.modelProperties,\n      recoverableDays: {\n        serializedName: \"recoverableDays\",\n        readOnly: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      recoveryLevel: {\n        serializedName: \"recoveryLevel\",\n        readOnly: true,\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const DeletedSecretBundle: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"DeletedSecretBundle\",\n    modelProperties: {\n      ...SecretBundle.type.modelProperties,\n      recoveryId: {\n        serializedName: \"recoveryId\",\n        type: {\n          name: \"String\"\n        }\n      },\n      scheduledPurgeDate: {\n        serializedName: \"scheduledPurgeDate\",\n        readOnly: true,\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      deletedDate: {\n        serializedName: \"deletedDate\",\n        readOnly: true,\n        type: {\n          name: \"UnixTime\"\n        }\n      }\n    }\n  }\n};\n\nexport const DeletedSecretItem: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"DeletedSecretItem\",\n    modelProperties: {\n      ...SecretItem.type.modelProperties,\n      recoveryId: {\n        serializedName: \"recoveryId\",\n        type: {\n          name: \"String\"\n        }\n      },\n      scheduledPurgeDate: {\n        serializedName: \"scheduledPurgeDate\",\n        readOnly: true,\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      deletedDate: {\n        serializedName: \"deletedDate\",\n        readOnly: true,\n        type: {\n          name: \"UnixTime\"\n        }\n      }\n    }\n  }\n};\n","/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport {\n  OperationParameter,\n  OperationURLParameter,\n  OperationQueryParameter\n} from \"@azure/core-http\";\nimport {\n  SecretSetParameters as SecretSetParametersMapper,\n  SecretUpdateParameters as SecretUpdateParametersMapper,\n  SecretRestoreParameters as SecretRestoreParametersMapper\n} from \"../models/mappers\";\n\nexport const contentType: OperationParameter = {\n  parameterPath: [\"options\", \"contentType\"],\n  mapper: {\n    defaultValue: \"application/json\",\n    isConstant: true,\n    serializedName: \"Content-Type\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const accept: OperationParameter = {\n  parameterPath: \"accept\",\n  mapper: {\n    defaultValue: \"application/json\",\n    isConstant: true,\n    serializedName: \"Accept\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const value: OperationParameter = {\n  parameterPath: \"value\",\n  mapper: SecretSetParametersMapper\n};\n\nexport const tags: OperationParameter = {\n  parameterPath: [\"options\", \"tags\"],\n  mapper: SecretSetParametersMapper\n};\n\nexport const contentType1: OperationParameter = {\n  parameterPath: [\"options\", \"contentType\"],\n  mapper: SecretSetParametersMapper\n};\n\nexport const secretAttributes: OperationParameter = {\n  parameterPath: [\"options\", \"secretAttributes\"],\n  mapper: SecretSetParametersMapper\n};\n\nexport const vaultBaseUrl: OperationURLParameter = {\n  parameterPath: \"vaultBaseUrl\",\n  mapper: {\n    serializedName: \"vaultBaseUrl\",\n    required: true,\n    type: {\n      name: \"String\"\n    }\n  },\n  skipEncoding: true\n};\n\nexport const secretName: OperationURLParameter = {\n  parameterPath: \"secretName\",\n  mapper: {\n    constraints: {\n      Pattern: new RegExp(\"^[0-9a-zA-Z-]+$\")\n    },\n    serializedName: \"secret-name\",\n    required: true,\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const apiVersion: OperationQueryParameter = {\n  parameterPath: \"apiVersion\",\n  mapper: {\n    serializedName: \"api-version\",\n    required: true,\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const secretName1: OperationURLParameter = {\n  parameterPath: \"secretName\",\n  mapper: {\n    serializedName: \"secret-name\",\n    required: true,\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const contentType2: OperationParameter = {\n  parameterPath: [\"options\", \"contentType\"],\n  mapper: SecretUpdateParametersMapper\n};\n\nexport const secretAttributes1: OperationParameter = {\n  parameterPath: [\"options\", \"secretAttributes\"],\n  mapper: SecretUpdateParametersMapper\n};\n\nexport const tags1: OperationParameter = {\n  parameterPath: [\"options\", \"tags\"],\n  mapper: SecretUpdateParametersMapper\n};\n\nexport const secretVersion: OperationURLParameter = {\n  parameterPath: \"secretVersion\",\n  mapper: {\n    serializedName: \"secret-version\",\n    required: true,\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const maxresults: OperationQueryParameter = {\n  parameterPath: [\"options\", \"maxresults\"],\n  mapper: {\n    constraints: {\n      InclusiveMaximum: 25,\n      InclusiveMinimum: 1\n    },\n    serializedName: \"maxresults\",\n    type: {\n      name: \"Number\"\n    }\n  }\n};\n\nexport const secretBundleBackup: OperationParameter = {\n  parameterPath: \"secretBundleBackup\",\n  mapper: SecretRestoreParametersMapper\n};\n\nexport const nextLink: OperationURLParameter = {\n  parameterPath: \"nextLink\",\n  mapper: {\n    serializedName: \"nextLink\",\n    required: true,\n    type: {\n      name: \"String\"\n    }\n  },\n  skipEncoding: true\n};\n","/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport * as coreHttp from \"@azure/core-http\";\nimport { ApiVersion72Preview, KeyVaultClientOptionalParams } from \"./models\";\n\nconst packageName = \"@azure/keyvault-secrets\";\nexport const packageVersion = \"4.2.0\";\n\n/** @hidden */\nexport class KeyVaultClientContext extends coreHttp.ServiceClient {\n  apiVersion: ApiVersion72Preview;\n\n  /**\n   * Initializes a new instance of the KeyVaultClientContext class.\n   * @param apiVersion Api Version\n   * @param options The parameter options\n   */\n  constructor(apiVersion: ApiVersion72Preview, options?: KeyVaultClientOptionalParams) {\n    if (apiVersion === undefined) {\n      throw new Error(\"'apiVersion' cannot be null\");\n    }\n\n    // Initializing default values for options\n    if (!options) {\n      options = {};\n    }\n\n    if (!options.userAgent) {\n      const defaultUserAgent = coreHttp.getDefaultUserAgentValue();\n      options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;\n    }\n\n    super(undefined, options);\n\n    this.requestContentType = \"application/json; charset=utf-8\";\n\n    this.baseUri = options.endpoint || \"{vaultBaseUrl}\";\n\n    // Parameter assignments\n    this.apiVersion = apiVersion;\n  }\n}\n","/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport * as coreHttp from \"@azure/core-http\";\nimport * as Parameters from \"./models/parameters\";\nimport * as Mappers from \"./models/mappers\";\nimport { KeyVaultClientContext } from \"./keyVaultClientContext\";\nimport {\n  KeyVaultClientOptionalParams,\n  ApiVersion72Preview,\n  KeyVaultClientSetSecretOptionalParams,\n  KeyVaultClientSetSecretResponse,\n  KeyVaultClientDeleteSecretResponse,\n  KeyVaultClientUpdateSecretOptionalParams,\n  KeyVaultClientUpdateSecretResponse,\n  KeyVaultClientGetSecretResponse,\n  KeyVaultClientGetSecretsOptionalParams,\n  KeyVaultClientGetSecretsResponse,\n  KeyVaultClientGetSecretVersionsOptionalParams,\n  KeyVaultClientGetSecretVersionsResponse,\n  KeyVaultClientGetDeletedSecretsOptionalParams,\n  KeyVaultClientGetDeletedSecretsResponse,\n  KeyVaultClientGetDeletedSecretResponse,\n  KeyVaultClientRecoverDeletedSecretResponse,\n  KeyVaultClientBackupSecretResponse,\n  KeyVaultClientRestoreSecretResponse,\n  KeyVaultClientGetSecretsNextOptionalParams,\n  KeyVaultClientGetSecretsNextResponse,\n  KeyVaultClientGetSecretVersionsNextOptionalParams,\n  KeyVaultClientGetSecretVersionsNextResponse,\n  KeyVaultClientGetDeletedSecretsNextOptionalParams,\n  KeyVaultClientGetDeletedSecretsNextResponse\n} from \"./models\";\n\n/** @hidden */\nexport class KeyVaultClient extends KeyVaultClientContext {\n  /**\n   * Initializes a new instance of the KeyVaultClient class.\n   * @param apiVersion Api Version\n   * @param options The parameter options\n   */\n  constructor(\n    apiVersion: ApiVersion72Preview,\n    options?: KeyVaultClientOptionalParams\n  ) {\n    super(apiVersion, options);\n  }\n\n  /**\n   *  The SET operation adds a secret to the Azure Key Vault. If the named secret already exists, Azure\n   * Key Vault creates a new version of that secret. This operation requires the secrets/set permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param value The value of the secret.\n   * @param options The options parameters.\n   */\n  setSecret(\n    vaultBaseUrl: string,\n    secretName: string,\n    value: string,\n    options?: KeyVaultClientSetSecretOptionalParams\n  ): Promise<KeyVaultClientSetSecretResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      secretName,\n      value,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      setSecretOperationSpec\n    ) as Promise<KeyVaultClientSetSecretResponse>;\n  }\n\n  /**\n   * The DELETE operation applies to any secret stored in Azure Key Vault. DELETE cannot be applied to an\n   * individual version of a secret. This operation requires the secrets/delete permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param options The options parameters.\n   */\n  deleteSecret(\n    vaultBaseUrl: string,\n    secretName: string,\n    options?: coreHttp.OperationOptions\n  ): Promise<KeyVaultClientDeleteSecretResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      secretName,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      deleteSecretOperationSpec\n    ) as Promise<KeyVaultClientDeleteSecretResponse>;\n  }\n\n  /**\n   * The UPDATE operation changes specified attributes of an existing stored secret. Attributes that are\n   * not specified in the request are left unchanged. The value of a secret itself cannot be changed.\n   * This operation requires the secrets/set permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param secretVersion The version of the secret.\n   * @param options The options parameters.\n   */\n  updateSecret(\n    vaultBaseUrl: string,\n    secretName: string,\n    secretVersion: string,\n    options?: KeyVaultClientUpdateSecretOptionalParams\n  ): Promise<KeyVaultClientUpdateSecretResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      secretName,\n      secretVersion,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      updateSecretOperationSpec\n    ) as Promise<KeyVaultClientUpdateSecretResponse>;\n  }\n\n  /**\n   * The GET operation is applicable to any secret stored in Azure Key Vault. This operation requires the\n   * secrets/get permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param secretVersion The version of the secret. This URI fragment is optional. If not specified, the\n   *                      latest version of the secret is returned.\n   * @param options The options parameters.\n   */\n  getSecret(\n    vaultBaseUrl: string,\n    secretName: string,\n    secretVersion: string,\n    options?: coreHttp.OperationOptions\n  ): Promise<KeyVaultClientGetSecretResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      secretName,\n      secretVersion,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getSecretOperationSpec\n    ) as Promise<KeyVaultClientGetSecretResponse>;\n  }\n\n  /**\n   * The Get Secrets operation is applicable to the entire vault. However, only the base secret\n   * identifier and its attributes are provided in the response. Individual secret versions are not\n   * listed in the response. This operation requires the secrets/list permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param options The options parameters.\n   */\n  getSecrets(\n    vaultBaseUrl: string,\n    options?: KeyVaultClientGetSecretsOptionalParams\n  ): Promise<KeyVaultClientGetSecretsResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getSecretsOperationSpec\n    ) as Promise<KeyVaultClientGetSecretsResponse>;\n  }\n\n  /**\n   * The full secret identifier and attributes are provided in the response. No values are returned for\n   * the secrets. This operations requires the secrets/list permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param options The options parameters.\n   */\n  getSecretVersions(\n    vaultBaseUrl: string,\n    secretName: string,\n    options?: KeyVaultClientGetSecretVersionsOptionalParams\n  ): Promise<KeyVaultClientGetSecretVersionsResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      secretName,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getSecretVersionsOperationSpec\n    ) as Promise<KeyVaultClientGetSecretVersionsResponse>;\n  }\n\n  /**\n   * The Get Deleted Secrets operation returns the secrets that have been deleted for a vault enabled for\n   * soft-delete. This operation requires the secrets/list permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param options The options parameters.\n   */\n  getDeletedSecrets(\n    vaultBaseUrl: string,\n    options?: KeyVaultClientGetDeletedSecretsOptionalParams\n  ): Promise<KeyVaultClientGetDeletedSecretsResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getDeletedSecretsOperationSpec\n    ) as Promise<KeyVaultClientGetDeletedSecretsResponse>;\n  }\n\n  /**\n   * The Get Deleted Secret operation returns the specified deleted secret along with its attributes.\n   * This operation requires the secrets/get permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param options The options parameters.\n   */\n  getDeletedSecret(\n    vaultBaseUrl: string,\n    secretName: string,\n    options?: coreHttp.OperationOptions\n  ): Promise<KeyVaultClientGetDeletedSecretResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      secretName,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getDeletedSecretOperationSpec\n    ) as Promise<KeyVaultClientGetDeletedSecretResponse>;\n  }\n\n  /**\n   * The purge deleted secret operation removes the secret permanently, without the possibility of\n   * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation requires\n   * the secrets/purge permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param options The options parameters.\n   */\n  purgeDeletedSecret(\n    vaultBaseUrl: string,\n    secretName: string,\n    options?: coreHttp.OperationOptions\n  ): Promise<coreHttp.RestResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      secretName,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      purgeDeletedSecretOperationSpec\n    ) as Promise<coreHttp.RestResponse>;\n  }\n\n  /**\n   * Recovers the deleted secret in the specified vault. This operation can only be performed on a\n   * soft-delete enabled vault. This operation requires the secrets/recover permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the deleted secret.\n   * @param options The options parameters.\n   */\n  recoverDeletedSecret(\n    vaultBaseUrl: string,\n    secretName: string,\n    options?: coreHttp.OperationOptions\n  ): Promise<KeyVaultClientRecoverDeletedSecretResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      secretName,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      recoverDeletedSecretOperationSpec\n    ) as Promise<KeyVaultClientRecoverDeletedSecretResponse>;\n  }\n\n  /**\n   * Requests that a backup of the specified secret be downloaded to the client. All versions of the\n   * secret will be downloaded. This operation requires the secrets/backup permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param options The options parameters.\n   */\n  backupSecret(\n    vaultBaseUrl: string,\n    secretName: string,\n    options?: coreHttp.OperationOptions\n  ): Promise<KeyVaultClientBackupSecretResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      secretName,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      backupSecretOperationSpec\n    ) as Promise<KeyVaultClientBackupSecretResponse>;\n  }\n\n  /**\n   * Restores a backed up secret, and all its versions, to a vault. This operation requires the\n   * secrets/restore permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretBundleBackup The backup blob associated with a secret bundle.\n   * @param options The options parameters.\n   */\n  restoreSecret(\n    vaultBaseUrl: string,\n    secretBundleBackup: Uint8Array,\n    options?: coreHttp.OperationOptions\n  ): Promise<KeyVaultClientRestoreSecretResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      secretBundleBackup,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      restoreSecretOperationSpec\n    ) as Promise<KeyVaultClientRestoreSecretResponse>;\n  }\n\n  /**\n   * GetSecretsNext\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param nextLink The nextLink from the previous successful call to the GetSecrets method.\n   * @param options The options parameters.\n   */\n  getSecretsNext(\n    vaultBaseUrl: string,\n    nextLink: string,\n    options?: KeyVaultClientGetSecretsNextOptionalParams\n  ): Promise<KeyVaultClientGetSecretsNextResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      nextLink,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getSecretsNextOperationSpec\n    ) as Promise<KeyVaultClientGetSecretsNextResponse>;\n  }\n\n  /**\n   * GetSecretVersionsNext\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param nextLink The nextLink from the previous successful call to the GetSecretVersions method.\n   * @param options The options parameters.\n   */\n  getSecretVersionsNext(\n    vaultBaseUrl: string,\n    secretName: string,\n    nextLink: string,\n    options?: KeyVaultClientGetSecretVersionsNextOptionalParams\n  ): Promise<KeyVaultClientGetSecretVersionsNextResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      secretName,\n      nextLink,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getSecretVersionsNextOperationSpec\n    ) as Promise<KeyVaultClientGetSecretVersionsNextResponse>;\n  }\n\n  /**\n   * GetDeletedSecretsNext\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param nextLink The nextLink from the previous successful call to the GetDeletedSecrets method.\n   * @param options The options parameters.\n   */\n  getDeletedSecretsNext(\n    vaultBaseUrl: string,\n    nextLink: string,\n    options?: KeyVaultClientGetDeletedSecretsNextOptionalParams\n  ): Promise<KeyVaultClientGetDeletedSecretsNextResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      nextLink,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getDeletedSecretsNextOperationSpec\n    ) as Promise<KeyVaultClientGetDeletedSecretsNextResponse>;\n  }\n}\n// Operation Specifications\nconst serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);\n\nconst setSecretOperationSpec: coreHttp.OperationSpec = {\n  path: \"/secrets/{secret-name}\",\n  httpMethod: \"PUT\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.SecretBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: {\n      value: [\"value\"],\n      tags: [\"options\", \"tags\"],\n      contentType: [\"options\", \"contentType\"],\n      secretAttributes: [\"options\", \"secretAttributes\"]\n    },\n    mapper: Mappers.SecretSetParameters\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.secretName],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst deleteSecretOperationSpec: coreHttp.OperationSpec = {\n  path: \"/secrets/{secret-name}\",\n  httpMethod: \"DELETE\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeletedSecretBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.secretName1],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst updateSecretOperationSpec: coreHttp.OperationSpec = {\n  path: \"/secrets/{secret-name}/{secret-version}\",\n  httpMethod: \"PATCH\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.SecretBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: {\n      contentType: [\"options\", \"contentType\"],\n      secretAttributes: [\"options\", \"secretAttributes\"],\n      tags: [\"options\", \"tags\"]\n    },\n    mapper: Mappers.SecretUpdateParameters\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.secretName1,\n    Parameters.secretVersion\n  ],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst getSecretOperationSpec: coreHttp.OperationSpec = {\n  path: \"/secrets/{secret-name}/{secret-version}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.SecretBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.secretName1,\n    Parameters.secretVersion\n  ],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst getSecretsOperationSpec: coreHttp.OperationSpec = {\n  path: \"/secrets\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.SecretListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.maxresults],\n  urlParameters: [Parameters.vaultBaseUrl],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst getSecretVersionsOperationSpec: coreHttp.OperationSpec = {\n  path: \"/secrets/{secret-name}/versions\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.SecretListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.maxresults],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.secretName1],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst getDeletedSecretsOperationSpec: coreHttp.OperationSpec = {\n  path: \"/deletedsecrets\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeletedSecretListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.maxresults],\n  urlParameters: [Parameters.vaultBaseUrl],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst getDeletedSecretOperationSpec: coreHttp.OperationSpec = {\n  path: \"/deletedsecrets/{secret-name}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeletedSecretBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.secretName1],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst purgeDeletedSecretOperationSpec: coreHttp.OperationSpec = {\n  path: \"/deletedsecrets/{secret-name}\",\n  httpMethod: \"DELETE\",\n  responses: {\n    204: {},\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.secretName1],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst recoverDeletedSecretOperationSpec: coreHttp.OperationSpec = {\n  path: \"/deletedsecrets/{secret-name}/recover\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.SecretBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.secretName1],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst backupSecretOperationSpec: coreHttp.OperationSpec = {\n  path: \"/secrets/{secret-name}/backup\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.BackupSecretResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.secretName1],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst restoreSecretOperationSpec: coreHttp.OperationSpec = {\n  path: \"/secrets/restore\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.SecretBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: { secretBundleBackup: [\"secretBundleBackup\"] },\n    mapper: Mappers.SecretRestoreParameters\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst getSecretsNextOperationSpec: coreHttp.OperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.SecretListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.maxresults],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.nextLink],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst getSecretVersionsNextOperationSpec: coreHttp.OperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.SecretListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.maxresults],\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.secretName1,\n    Parameters.nextLink\n  ],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst getDeletedSecretsNextOperationSpec: coreHttp.OperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeletedSecretListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.maxresults],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.nextLink],\n  headerParameters: [Parameters.accept],\n  serializer\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nexport const SDK_VERSION: string = \"4.2.0\";\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/* eslint-disable @azure/azure-sdk/ts-use-interface-parameters */\n\nimport { TokenCredential } from \"@azure/core-http\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyOptions,\n  RequestPolicyFactory\n} from \"@azure/core-http\";\nimport { Constants } from \"@azure/core-http\";\nimport { HttpOperationResponse } from \"@azure/core-http\";\nimport { WebResource } from \"@azure/core-http\";\nimport { AccessTokenCache, ExpiringAccessTokenCache } from \"@azure/core-http\";\n\ntype ValidParsedWWWAuthenticateProperties =\n  // \"authorization_uri\" was used in the track 1 version of KeyVault.\n  // This is not a relevant property anymore, since the service is consistently answering with \"authorization\".\n  // | \"authorization_uri\"\n  | \"authorization\"\n  // Even though the service is moving to \"scope\", both \"resource\" and \"scope\" should be supported.\n  | \"resource\"\n  | \"scope\";\n\ntype ParsedWWWAuthenticate = {\n  [Key in ValidParsedWWWAuthenticateProperties]?: string;\n};\n\n/**\n * Representation of the Authentication Challenge\n */\nexport class AuthenticationChallenge {\n  constructor(public authorization: string, public scope: string) {}\n\n  /**\n   * Checks that this AuthenticationChallenge is equal to another one given.\n   * Only compares the scope.\n   * This is exactly what C# is doing, as we can see here:\n   * https://github.com/Azure/azure-sdk-for-net/blob/70e54b878ff1d01a45266fb3674a396b4ab9c1d2/sdk/keyvault/Azure.Security.KeyVault.Shared/src/ChallengeBasedAuthenticationPolicy.cs#L143-L147\n   * @param other - The other AuthenticationChallenge\n   */\n  public equalTo(other: AuthenticationChallenge | undefined): boolean {\n    return other\n      ? this.scope.toLowerCase() === other.scope.toLowerCase() &&\n          this.authorization.toLowerCase() === other.authorization.toLowerCase()\n      : false;\n  }\n}\n\n/**\n * Helps keep a copy of any previous authentication challenges,\n * so that we can compare on any further request.\n */\nexport class AuthenticationChallengeCache {\n  public challenge?: AuthenticationChallenge;\n\n  public setCachedChallenge(challenge: AuthenticationChallenge): void {\n    this.challenge = challenge;\n  }\n}\n\n/**\n * Creates a new ChallengeBasedAuthenticationPolicy factory.\n *\n * @param credential - The TokenCredential implementation that can supply the challenge token.\n */\nexport function challengeBasedAuthenticationPolicy(\n  credential: TokenCredential\n): RequestPolicyFactory {\n  const tokenCache: AccessTokenCache = new ExpiringAccessTokenCache();\n  const challengeCache = new AuthenticationChallengeCache();\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new ChallengeBasedAuthenticationPolicy(\n        nextPolicy,\n        options,\n        credential,\n        tokenCache,\n        challengeCache\n      );\n    }\n  };\n}\n\n/**\n * Parses an WWW-Authenticate response.\n * This transforms a string value like:\n * `Bearer authorization=\"some_authorization\", resource=\"https://some.url\"`\n * into an object like:\n * `{ authorization: \"some_authorization\", resource: \"https://some.url\" }`\n * @param wwwAuthenticate - String value in the WWW-Authenticate header\n */\nexport function parseWWWAuthenticate(wwwAuthenticate: string): ParsedWWWAuthenticate {\n  // First we split the string by either `, ` or ` `.\n  const parts = wwwAuthenticate.split(/,* +/);\n  // Then we only keep the strings with an equal sign after a word and before a quote.\n  // also splitting these sections by their equal sign\n  const keyValues = parts.reduce<string[][]>(\n    (acc, str) => (str.match(/\\w=\"/) ? [...acc, str.split(\"=\")] : acc),\n    []\n  );\n  // Then we transform these key-value pairs back into an object.\n  const parsed = keyValues.reduce<ParsedWWWAuthenticate>(\n    (result, [key, value]: string[]) => ({\n      ...result,\n      [key]: value.slice(1, -1)\n    }),\n    {}\n  );\n  return parsed;\n}\n\n/**\n *\n * Provides a RequestPolicy that can request a token from a TokenCredential\n * implementation and then apply it to the Authorization header of a request\n * as a Bearer token.\n *\n */\nexport class ChallengeBasedAuthenticationPolicy extends BaseRequestPolicy {\n  private parseWWWAuthenticate: (\n    wwwAuthenticate: string\n  ) => ParsedWWWAuthenticate = parseWWWAuthenticate;\n\n  /**\n   * Creates a new ChallengeBasedAuthenticationPolicy object.\n   *\n   * @param nextPolicy - The next RequestPolicy in the request pipeline.\n   * @param options - Options for this RequestPolicy.\n   * @param credential - The TokenCredential implementation that can supply the bearer token.\n   * @param tokenCache - The cache for the most recent AccessToken returned by the TokenCredential.\n   */\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    private credential: TokenCredential,\n    private tokenCache: AccessTokenCache,\n    private challengeCache: AuthenticationChallengeCache\n  ) {\n    super(nextPolicy, options);\n  }\n\n  /**\n   * Gets or updates the token from the token cache into the headers of the received web resource.\n   */\n  private async loadToken(webResource: WebResource): Promise<void> {\n    let accessToken = this.tokenCache.getCachedToken();\n\n    // If there's no cached token in the cache, we try to get a new one.\n    if (accessToken === undefined) {\n      const receivedToken = await this.credential.getToken(this.challengeCache.challenge!.scope);\n      accessToken = receivedToken || undefined;\n      this.tokenCache.setCachedToken(accessToken);\n    }\n\n    if (accessToken) {\n      webResource.headers.set(\n        Constants.HeaderConstants.AUTHORIZATION,\n        `Bearer ${accessToken.token}`\n      );\n    }\n  }\n\n  /**\n   * Parses the given WWW-Authenticate header, generates a new AuthenticationChallenge,\n   * then if the challenge is different from the one cached, resets the token and forces\n   * a re-authentication, otherwise continues with the existing challenge and token.\n   * @param wwwAuthenticate - Value of the incoming WWW-Authenticate header.\n   * @param webResource - Ongoing HTTP request.\n   */\n  private async regenerateChallenge(\n    wwwAuthenticate: string,\n    webResource: WebResource\n  ): Promise<HttpOperationResponse> {\n    // The challenge based authentication will contain both:\n    // - An authorization URI with a token,\n    // - The resource to which that token is valid against (also called the scope).\n    const parsedWWWAuth = this.parseWWWAuthenticate(wwwAuthenticate);\n    const authorization = parsedWWWAuth.authorization!;\n    const resource = parsedWWWAuth.resource! || parsedWWWAuth.scope!;\n\n    if (!(authorization && resource)) {\n      return this._nextPolicy.sendRequest(webResource);\n    }\n\n    const challenge = new AuthenticationChallenge(authorization, resource + \"/.default\");\n\n    // Either if there's no cached challenge at this point (could have happen in parallel),\n    // or if the cached challenge has a different scope,\n    // we store the just received challenge and reset the cached token, to force a re-authentication.\n    if (!this.challengeCache.challenge?.equalTo(challenge)) {\n      this.challengeCache.setCachedChallenge(challenge);\n      this.tokenCache.setCachedToken(undefined);\n    }\n\n    await this.loadToken(webResource);\n    return this._nextPolicy.sendRequest(webResource);\n  }\n\n  /**\n   * Applies the Bearer token to the request through the Authorization header.\n   * @param webResource - Ongoing HTTP request.\n   */\n  public async sendRequest(webResource: WebResource): Promise<HttpOperationResponse> {\n    // Ensure that we're about to use a secure connection.\n    if (!webResource.url.startsWith(\"https:\")) {\n      throw new Error(\"The resource address for authorization must use the 'https' protocol.\");\n    }\n\n    // The next request will happen differently whether we have a challenge or not.\n    let response: HttpOperationResponse;\n\n    if (\n      this.challengeCache.challenge === undefined ||\n      this.challengeCache.challenge === undefined\n    ) {\n      // If there's no challenge in cache, a blank body will start the challenge.\n      const originalBody = webResource.body;\n      webResource.body = \"\";\n      try {\n        response = await this._nextPolicy.sendRequest(webResource);\n      } finally {\n        webResource.body = originalBody;\n      }\n    } else {\n      // If we did have a challenge in memory,\n      // we attempt to load the token from the cache into the request before we try to send the request.\n      await this.loadToken(webResource);\n      response = await this._nextPolicy.sendRequest(webResource);\n    }\n\n    // If we don't receive a response with a 401 status code,\n    // then we can assume this response has nothing to do with the challenge authentication process.\n    if (response.status !== 401) {\n      return response;\n    }\n\n    // If the response status is 401, we only re-authenticate if the WWW-Authenticate header is present.\n    const wwwAuthenticate = response.headers.get(\"WWW-Authenticate\");\n    if (!wwwAuthenticate) {\n      return response;\n    }\n\n    // We re-generate the challenge and see if we have to re-authenticate.\n    return this.regenerateChallenge(wwwAuthenticate, webResource);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as url from \"url\";\n\nexport interface ParsedKeyVaultEntityIdentifier {\n  /**\n   * The vault URI.\n   */\n  vaultUrl: string;\n  /**\n   * The version of key/secret/certificate. May be undefined.\n   */\n  version?: string;\n  /**\n   * The name of key/secret/certificate.\n   */\n  name: string;\n}\nexport function parseKeyvaultIdentifier(\n  collection: string,\n  identifier: string | undefined\n): ParsedKeyVaultEntityIdentifier {\n  if (typeof collection !== \"string\" || !(collection = collection.trim())) {\n    throw new Error(\"Invalid collection argument\");\n  }\n\n  if (typeof identifier !== \"string\" || !(identifier = identifier.trim())) {\n    throw new Error(\"Invalid identifier argument\");\n  }\n\n  let baseUri;\n  try {\n    baseUri = url.parse(identifier, true, true);\n  } catch (e) {\n    throw new Error(`Invalid ${collection} identifier: ${identifier}. Not a valid URI`);\n  }\n\n  // Path is of the form '/collection/name[/version]'\n  const segments = (baseUri.pathname || \"\").split(\"/\");\n  if (segments.length !== 3 && segments.length !== 4) {\n    throw new Error(\n      `Invalid ${collection} identifier: ${identifier}. Bad number of segments: ${segments.length}`\n    );\n  }\n\n  if (collection !== segments[1]) {\n    throw new Error(\n      `Invalid ${collection} identifier: ${identifier}. segment [1] should be \"${collection}\", found \"${segments[1]}\"`\n    );\n  }\n\n  const vaultUrl = `${baseUri.protocol}//${baseUri.host}`;\n  const name = segments[2];\n  const version = segments.length === 4 ? segments[3] : undefined;\n  return {\n    vaultUrl,\n    name,\n    version\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { OperationOptions } from \"@azure/core-http\";\nimport { createSpanFunction, Span, SpanStatusCode } from \"@azure/core-tracing\";\n\n/**\n * An interface representing a function that is traced.\n *\n * A traced function will automatically create and close tracing '\n * spans as needed and will handle setting the status / errors as a\n * result of calling the underlying callback.\n *\n * use {@link createTraceFunction} to add tracing to a block of code.\n *\n * @internal\n */\nexport interface TracedFunction {\n  <TOptions extends OperationOptions, TReturn>(\n    operationName: string,\n    options: TOptions,\n    cb: (options: TOptions, span: Span) => Promise<TReturn>\n  ): Promise<TReturn>;\n}\n\n/**\n * Returns a function that can be used for tracing options.\n *\n * @param prefix - The prefix to use, likely the name of the class / client.\n *\n * @example const withTrace = createTraceFunction(\"Azure.KeyVault.Certificates.CertificateClient\")\n *\n * @internal\n */\nexport function createTraceFunction(prefix: string): TracedFunction {\n  const createSpan = createSpanFunction({\n    namespace: \"Microsoft.KeyVault\",\n    packagePrefix: prefix\n  });\n\n  return async function(operationName, options, cb) {\n    const { updatedOptions, span } = createSpan(operationName, options);\n\n    try {\n      // NOTE: we really do need to await on this function here so we can handle any exceptions thrown and properly\n      // close the span.\n      const result = await cb(updatedOptions, span);\n\n      // otel 0.16+ needs this or else the code ends up being set as UNSET\n      span.setStatus({\n        code: SpanStatusCode.OK\n      });\n      return result;\n    } catch (err) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err.message\n      });\n      throw err;\n    } finally {\n      span.end();\n    }\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { delay, OperationOptions } from \"@azure/core-http\";\nimport { Poller, PollOperation, PollOperationState } from \"@azure/core-lro\";\nimport { KeyVaultClient } from \"../generated/keyVaultClient\";\n\n/**\n * Common parameters to a Key Vault Secret Poller.\n */\nexport interface KeyVaultSecretPollerOptions {\n  vaultUrl: string;\n  client: KeyVaultClient;\n  name: string;\n  operationOptions?: OperationOptions;\n  intervalInMs?: number;\n  resumeFrom?: string;\n}\n\n/**\n * An interface representing the state of a Key Vault Secret Poller's operation.\n */\nexport interface KeyVaultSecretPollOperationState<TResult> extends PollOperationState<TResult> {\n  /**\n   * The name of the secret.\n   */\n  name: string;\n}\n\n/**\n * Common properties and methods of the Key Vault Secret Pollers.\n */\nexport abstract class KeyVaultSecretPoller<\n  TState extends KeyVaultSecretPollOperationState<TResult>,\n  TResult\n> extends Poller<TState, TResult> {\n  /**\n   * Defines how much time the poller is going to wait before making a new request to the service.\n   */\n  public intervalInMs: number = 2000;\n\n  /**\n   * The method used by the poller to wait before attempting to update its operation.\n   */\n  async delay(): Promise<void> {\n    return delay(this.intervalInMs);\n  }\n}\n\n/**\n * Optional parameters to the KeyVaultSecretPollOperation\n */\nexport interface KeyVaultSecretPollOperationOptions {\n  cancelMessage?: string;\n}\n\n/**\n * Common properties and methods of the Key Vault Secret Poller operations.\n */\n// eslint-disable-next-next no-use-before-define\nexport class KeyVaultSecretPollOperation<\n  TState extends KeyVaultSecretPollOperationState<TResult>,\n  TResult\n> implements PollOperation<TState, TResult> {\n  private cancelMessage: string = \"\";\n\n  constructor(public state: TState, options: KeyVaultSecretPollOperationOptions = {}) {\n    if (options.cancelMessage) {\n      this.cancelMessage = options.cancelMessage;\n    }\n  }\n\n  /**\n   * Meant to reach to the service and update the Poller operation.\n   * @param options - The optional parameters, which is only an abortSignal from \\@azure/abort-controller\n   */\n  public async update(): Promise<PollOperation<TState, TResult>> {\n    throw new Error(\"Operation not supported.\");\n  }\n\n  /**\n   * Meant to reach to the service and cancel the Poller operation.\n   * @param options - The optional parameters, which is only an abortSignal from \\@azure/abort-controller\n   */\n  public async cancel(): Promise<PollOperation<TState, TResult>> {\n    throw new Error(this.cancelMessage);\n  }\n\n  /**\n   * Serializes the Poller operation.\n   */\n  public toString(): string {\n    return JSON.stringify({\n      state: this.state\n    });\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { parseKeyvaultIdentifier } from \"../../keyvault-common/src\";\n\n/**\n * Represents the segments that compose a Key Vault Secret Id.\n */\nexport interface KeyVaultSecretIdentifier {\n  /**\n   * The complete representation of the Key Vault Secret Id. For example:\n   *\n   *   https://<keyvault-name>.vault.azure.net/secrets/<secret-name>/<unique-version-id>\n   *\n   */\n  sourceId: string;\n\n  /**\n   * The URL of the Azure Key Vault instance to which the Secret belongs.\n   */\n  vaultUrl: string;\n\n  /**\n   * The version of Key Vault Secret. Might be undefined.\n   */\n  version?: string;\n\n  /**\n   * The name of the Key Vault Secret.\n   */\n  name: string;\n}\n\n/**\n * Parses the given Key Vault Secret Id. An example is:\n *\n *   https://<keyvault-name>.vault.azure.net/secrets/<secret-name>/<unique-version-id>\n *\n * On parsing the above Id, this function returns:\n *```ts\n *   {\n *      sourceId: \"https://<keyvault-name>.vault.azure.net/secrets/<secret-name>/<unique-version-id>\",\n *      vaultUrl: \"https://<keyvault-name>.vault.azure.net\",\n *      version: \"<unique-version-id>\",\n *      name: \"<secret-name>\"\n *   }\n *```\n * @param id - The Id of the Key Vault Secret.\n */\nexport function parseKeyVaultSecretIdentifier(id: string): KeyVaultSecretIdentifier {\n  const urlParts = id.split(\"/\");\n  const collection = urlParts[3];\n\n  return {\n    sourceId: id,\n    ...parseKeyvaultIdentifier(collection, id)\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { DeletedSecretBundle, SecretBundle } from \"./generated/models\";\nimport { parseKeyVaultSecretIdentifier } from \"./identifier\";\nimport { DeletedSecret, KeyVaultSecret } from \"./secretsModels\";\n\n/**\n * @internal\n * Shapes the exposed {@link KeyVaultKey} based on either a received secret bundle or deleted secret bundle.\n */\nexport function getSecretFromSecretBundle(\n  bundle: SecretBundle | DeletedSecretBundle\n): KeyVaultSecret {\n  const secretBundle = bundle as SecretBundle;\n  const deletedSecretBundle = bundle as DeletedSecretBundle;\n  const parsedId = parseKeyVaultSecretIdentifier(secretBundle.id!);\n\n  const attributes = secretBundle.attributes;\n  delete secretBundle.attributes;\n\n  const resultObject: KeyVaultSecret & DeletedSecret = {\n    value: secretBundle.value,\n    name: parsedId.name,\n    properties: {\n      expiresOn: attributes?.expires,\n      createdOn: attributes?.created,\n      updatedOn: attributes?.updated,\n      enabled: attributes?.enabled,\n      notBefore: attributes?.notBefore,\n      recoverableDays: attributes?.recoverableDays,\n      recoveryLevel: attributes?.recoveryLevel,\n\n      id: secretBundle.id,\n      contentType: secretBundle.contentType,\n      tags: secretBundle.tags,\n      managed: secretBundle.managed,\n\n      vaultUrl: parsedId.vaultUrl,\n      version: parsedId.version,\n      name: parsedId.name,\n      certificateKeyId: secretBundle.kid\n    }\n  };\n\n  if (deletedSecretBundle.recoveryId) {\n    resultObject.properties.recoveryId = deletedSecretBundle.recoveryId;\n    resultObject.properties.scheduledPurgeDate = deletedSecretBundle.scheduledPurgeDate;\n    resultObject.properties.deletedOn = deletedSecretBundle.deletedDate;\n    resultObject.recoveryId = deletedSecretBundle.recoveryId;\n    resultObject.scheduledPurgeDate = deletedSecretBundle.scheduledPurgeDate;\n    resultObject.deletedOn = deletedSecretBundle.deletedDate;\n  }\n\n  if (attributes) {\n    if ((attributes as any).vaultUrl) {\n      delete (resultObject.properties as any).vaultUrl;\n    }\n\n    if (attributes.expires) {\n      delete (resultObject.properties as any).expires;\n    }\n\n    if (attributes.created) {\n      delete (resultObject.properties as any).created;\n    }\n\n    if (attributes.updated) {\n      delete (resultObject.properties as any).updated;\n    }\n  }\n\n  return resultObject;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { DeletedSecret, DeleteSecretOptions, GetDeletedSecretOptions } from \"../../secretsModels\";\nimport {\n  KeyVaultSecretPollOperation,\n  KeyVaultSecretPollOperationState\n} from \"../keyVaultSecretPoller\";\nimport { KeyVaultClient } from \"../../generated/keyVaultClient\";\nimport { getSecretFromSecretBundle } from \"../../transformations\";\nimport { OperationOptions } from \"@azure/core-http\";\nimport { createTraceFunction } from \"../../../../keyvault-common/src\";\n\n/**\n * @internal\n */\nconst withTrace = createTraceFunction(\"Azure.KeyVault.Secrets.DeleteSecretPoller\");\n\n/**\n * An interface representing the state of a delete secret's poll operation\n */\nexport interface DeleteSecretPollOperationState\n  extends KeyVaultSecretPollOperationState<DeletedSecret> {}\n\n/**\n * An interface representing a delete secret's poll operation\n */\nexport class DeleteSecretPollOperation extends KeyVaultSecretPollOperation<\n  DeleteSecretPollOperationState,\n  DeletedSecret\n> {\n  constructor(\n    public state: DeleteSecretPollOperationState,\n    private vaultUrl: string,\n    private client: KeyVaultClient,\n    private operationOptions: OperationOptions = {}\n  ) {\n    super(state, { cancelMessage: \"Canceling the deletion of a secret is not supported.\" });\n  }\n\n  /**\n   * Sends a delete request for the given Key Vault Key's name to the Key Vault service.\n   * Since the Key Vault Key won't be immediately deleted, we have {@link beginDeleteKey}.\n   */\n  private deleteSecret(name: string, options: DeleteSecretOptions = {}): Promise<DeletedSecret> {\n    return withTrace(\"deleteSecret\", options, async (updatedOptions) => {\n      const response = await this.client.deleteSecret(this.vaultUrl, name, updatedOptions);\n      return getSecretFromSecretBundle(response);\n    });\n  }\n\n  /**\n   * The getDeletedSecret method returns the specified deleted secret along with its properties.\n   * This operation requires the secrets/get permission.\n   */\n  private getDeletedSecret(\n    name: string,\n    options: GetDeletedSecretOptions = {}\n  ): Promise<DeletedSecret> {\n    return withTrace(\"getDeletedSecret\", options, async (updatedOptions) => {\n      const response = await this.client.getDeletedSecret(this.vaultUrl, name, updatedOptions);\n      return getSecretFromSecretBundle(response);\n    });\n  }\n\n  /**\n   * Reaches to the service and updates the delete secret's poll operation.\n   */\n  public async update(\n    options: {\n      abortSignal?: AbortSignalLike;\n      fireProgress?: (state: DeleteSecretPollOperationState) => void;\n    } = {}\n  ): Promise<DeleteSecretPollOperation> {\n    const state = this.state;\n    const { name } = state;\n\n    if (options.abortSignal) {\n      this.operationOptions.abortSignal = options.abortSignal;\n    }\n\n    if (!state.isStarted) {\n      const deletedSecret = await this.deleteSecret(name, this.operationOptions);\n      state.isStarted = true;\n      state.result = deletedSecret;\n      if (!deletedSecret.properties.recoveryId) {\n        state.isCompleted = true;\n      }\n    }\n\n    if (!state.isCompleted) {\n      try {\n        state.result = await this.getDeletedSecret(name, this.operationOptions);\n        state.isCompleted = true;\n      } catch (error) {\n        if (error.statusCode === 403) {\n          // At this point, the resource exists but the user doesn't have access to it.\n          state.isCompleted = true;\n        } else if (error.statusCode !== 404) {\n          state.error = error;\n          state.isCompleted = true;\n          throw error;\n        }\n      }\n    }\n\n    return this;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { DeleteSecretPollOperation, DeleteSecretPollOperationState } from \"./operation\";\nimport { DeletedSecret } from \"../../secretsModels\";\nimport { KeyVaultSecretPoller, KeyVaultSecretPollerOptions } from \"../keyVaultSecretPoller\";\n\n/**\n * Class that creates a poller that waits until a secret finishes being deleted.\n */\nexport class DeleteSecretPoller extends KeyVaultSecretPoller<\n  DeleteSecretPollOperationState,\n  DeletedSecret\n> {\n  constructor(options: KeyVaultSecretPollerOptions) {\n    const { vaultUrl, client, name, operationOptions, intervalInMs = 2000, resumeFrom } = options;\n\n    let state: DeleteSecretPollOperationState | undefined;\n\n    if (resumeFrom) {\n      state = JSON.parse(resumeFrom).state;\n    }\n\n    const operation = new DeleteSecretPollOperation(\n      {\n        ...state,\n        name\n      },\n      vaultUrl,\n      client,\n      operationOptions\n    );\n\n    super(operation);\n\n    this.intervalInMs = intervalInMs;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport {\n  DeletedSecret,\n  GetSecretOptions,\n  KeyVaultSecret,\n  SecretProperties\n} from \"../../secretsModels\";\nimport {\n  KeyVaultSecretPollOperation,\n  KeyVaultSecretPollOperationState\n} from \"../keyVaultSecretPoller\";\nimport { KeyVaultClient } from \"../../generated/keyVaultClient\";\nimport { getSecretFromSecretBundle } from \"../../transformations\";\nimport { OperationOptions } from \"@azure/core-http\";\n\nimport { createTraceFunction } from \"../../../../keyvault-common/src\";\n\n/**\n * @internal\n */\nconst withTrace = createTraceFunction(\"Azure.KeyVault.Secrets.RecoverDeletedSecretPoller\");\n\n/**\n * An interface representing the state of a delete secret's poll operation\n */\nexport interface RecoverDeletedSecretPollOperationState\n  extends KeyVaultSecretPollOperationState<SecretProperties> {}\n\n/**\n * An interface representing a delete secret's poll operation\n */\nexport class RecoverDeletedSecretPollOperation extends KeyVaultSecretPollOperation<\n  RecoverDeletedSecretPollOperationState,\n  SecretProperties\n> {\n  constructor(\n    public state: RecoverDeletedSecretPollOperationState,\n    private vaultUrl: string,\n    private client: KeyVaultClient,\n    private options: OperationOptions = {}\n  ) {\n    super(state, { cancelMessage: \"Canceling the recovery of a deleted secret is not supported.\" });\n  }\n\n  /**\n   * The getSecret method returns the specified secret along with its properties.\n   * This operation requires the secrets/get permission.\n   */\n  private getSecret(name: string, options: GetSecretOptions = {}): Promise<KeyVaultSecret> {\n    return withTrace(\"getSecret\", options, async (updatedOptions) => {\n      const response = await this.client.getSecret(\n        this.vaultUrl,\n        name,\n        options && options.version ? options.version : \"\",\n        updatedOptions\n      );\n      return getSecretFromSecretBundle(response);\n    });\n  }\n\n  /**\n   * The recoverDeletedSecret method recovers the specified deleted secret along with its properties.\n   * This operation requires the secrets/recover permission.\n   */\n  private recoverDeletedSecret(\n    name: string,\n    options: GetSecretOptions = {}\n  ): Promise<DeletedSecret> {\n    return withTrace(\"recoverDeletedSecret\", options, async (updatedOptions) => {\n      const response = await this.client.recoverDeletedSecret(this.vaultUrl, name, updatedOptions);\n      return getSecretFromSecretBundle(response);\n    });\n  }\n\n  /**\n   * Reaches to the service and updates the delete secret's poll operation.\n   */\n  async update(\n    this: RecoverDeletedSecretPollOperation,\n    options: {\n      abortSignal?: AbortSignalLike;\n      fireProgress?: (state: RecoverDeletedSecretPollOperationState) => void;\n    } = {}\n  ): Promise<RecoverDeletedSecretPollOperation> {\n    const state = this.state;\n    const { name } = state;\n\n    if (options.abortSignal) {\n      this.options.abortSignal = options.abortSignal;\n    }\n\n    if (!state.isStarted) {\n      try {\n        state.result = (await this.getSecret(name, this.options)).properties;\n        state.isCompleted = true;\n      } catch {\n        // Nothing to do here.\n      }\n      if (!state.isCompleted) {\n        state.result = (await this.recoverDeletedSecret(name, this.options)).properties;\n        state.isStarted = true;\n      }\n    }\n\n    if (!state.isCompleted) {\n      try {\n        state.result = (await this.getSecret(name, this.options)).properties;\n        state.isCompleted = true;\n      } catch (error) {\n        if (error.statusCode === 403) {\n          // At this point, the resource exists but the user doesn't have access to it.\n          state.isCompleted = true;\n        } else if (error.statusCode !== 404) {\n          state.error = error;\n          state.isCompleted = true;\n          throw error;\n        }\n      }\n    }\n\n    return this;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  RecoverDeletedSecretPollOperation,\n  RecoverDeletedSecretPollOperationState\n} from \"./operation\";\nimport { SecretProperties } from \"../../secretsModels\";\nimport { KeyVaultSecretPoller, KeyVaultSecretPollerOptions } from \"../keyVaultSecretPoller\";\n\n/**\n * Class that deletes a poller that waits until a secret finishes being deleted\n */\nexport class RecoverDeletedSecretPoller extends KeyVaultSecretPoller<\n  RecoverDeletedSecretPollOperationState,\n  SecretProperties\n> {\n  constructor(options: KeyVaultSecretPollerOptions) {\n    const { vaultUrl, client, name, operationOptions, intervalInMs = 2000, resumeFrom } = options;\n\n    let state: RecoverDeletedSecretPollOperationState | undefined;\n\n    if (resumeFrom) {\n      state = JSON.parse(resumeFrom).state;\n    }\n\n    const operation = new RecoverDeletedSecretPollOperation(\n      {\n        ...state,\n        name\n      },\n      vaultUrl,\n      client,\n      operationOptions\n    );\n\n    super(operation);\n\n    this.intervalInMs = intervalInMs;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as coreHttp from \"@azure/core-http\";\nimport { DeletionRecoveryLevel } from \"./generated/models\";\n\n/**\n * The latest supported KeyVault service API version\n */\nexport const LATEST_API_VERSION = \"7.2\";\n\n/**\n * The optional parameters accepted by the KeyVault's KeyClient\n */\nexport interface SecretClientOptions extends coreHttp.PipelineOptions {\n  /**\n   * The accepted versions of the KeyVault's service API.\n   */\n  serviceVersion?: \"7.0\" | \"7.1\" | \"7.2\";\n}\n\n/**\n * An interface representing a KeyVault Secret, with its name, value and {@link SecretProperties}.\n */\nexport interface KeyVaultSecret {\n  /**\n   * The properties of the secret.\n   */\n  properties: SecretProperties;\n  /**\n   * The value of the secret.\n   */\n  value?: string;\n  /**\n   * The name of the secret.\n   */\n  name: string;\n}\n\n/**\n * An interface representing the properties of a {@link KeyVaultSecret}.\n */\nexport interface SecretProperties {\n  /**\n   * The base URL to the vault.\n   */\n  vaultUrl: string;\n  /**\n   * The version of the secret. May be undefined.\n   */\n  version?: string;\n  /**\n   * The name of the secret.\n   */\n  name: string;\n  /**\n   * The secret id.\n   */\n  id?: string;\n  /**\n   * The content type of the secret.\n   */\n  contentType?: string;\n  /**\n   * Determines whether the object is enabled.\n   */\n  enabled?: boolean;\n  /**\n   * Not before date in UTC.\n   */\n  readonly notBefore?: Date;\n  /**\n   * Expiry date in UTC.\n   */\n  readonly expiresOn?: Date;\n  /**\n   * Application specific\n   * metadata in the form of key-value pairs.\n   */\n  tags?: { [propertyName: string]: string };\n  /**\n   * If this is a secret backing a KV certificate, then\n   * this field specifies the corresponding key backing the KV certificate.\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   * @deprecated Please use {@link SecretProperties.certificateKeyId} instead. `keyId` will always be undefined.\n   */\n  readonly keyId?: never;\n\n  /**\n   * If this is a secret backing a KV certificate, then\n   * this field specifies the identifier of the corresponding key backing the KV certificate.\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  readonly certificateKeyId?: string;\n\n  /**\n   * True if the secret's lifetime is managed by\n   * key vault. If this is a secret backing a certificate, then managed will be\n   * true.\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  readonly managed?: boolean;\n  /**\n   * Creation time in UTC.\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  readonly createdOn?: Date;\n  /**\n   * Last updated time in UTC.\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  readonly updatedOn?: Date;\n  /**\n   * Reflects the deletion\n   * recovery level currently in effect for keys in the current vault. If it\n   * contains 'Purgeable' the key can be permanently deleted by a privileged\n   * user; otherwise, only the system can purge the key, at the end of the\n   * retention interval. Possible values include: 'Purgeable',\n   * 'Recoverable+Purgeable', 'Recoverable',\n   * 'Recoverable+ProtectedSubscription'\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  readonly recoveryLevel?: DeletionRecoveryLevel;\n  /**\n   * The retention dates of the softDelete data.\n   * The value should be `>=7` and `<=90` when softDelete enabled.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  recoverableDays?: number;\n}\n\n/**\n * An interface representing a deleted KeyVault Secret.\n */\nexport interface DeletedSecret {\n  /**\n   * The properties of the secret\n   */\n  properties: SecretProperties & {\n    /**\n     * The url of the recovery object, used to\n     * identify and recover the deleted secret.\n     * @deprecated Please use {@link DeletedSecret.recoveryId}.\n     */\n    recoveryId?: string;\n    /**\n     * The time when the secret is scheduled\n     * to be purged, in UTC\n     * **NOTE: This property will not be serialized. It can only be populated by\n     * the server.**\n     * @deprecated Please use {@link DeletedSecret.scheduledPurgeDate}.\n     */\n    scheduledPurgeDate?: Date;\n    /**\n     * The time when the secret was deleted, in UTC\n     * **NOTE: This property will not be serialized. It can only be populated by\n     * the server.**\n     * @deprecated Please use {@link DeletedSecret.deletedOn}.\n     */\n    deletedOn?: Date;\n  };\n  /**\n   * The secret value.\n   */\n  value?: string;\n  /**\n   * The name of the secret.\n   */\n  name: string;\n  /**\n   * The url of the recovery object, used to\n   * identify and recover the deleted secret.\n   */\n  recoveryId?: string;\n  /**\n   * The time when the secret is scheduled\n   * to be purged, in UTC\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  scheduledPurgeDate?: Date;\n  /**\n   * The time when the secret was deleted, in UTC\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  deletedOn?: Date;\n}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link beginDeleteSecret} and {@link beginRecoverDeletedKey}.\n */\nexport interface SecretPollerOptions extends coreHttp.OperationOptions {\n  /**\n   * Time between each polling in milliseconds.\n   */\n  intervalInMs?: number;\n  /**\n   * A serialized poller, used to resume an existing operation\n   */\n  resumeFrom?: string;\n}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link beginDeleteSecret}\n */\nexport interface BeginDeleteSecretOptions extends SecretPollerOptions {}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link beginRecoverDeletedSecret}\n */\nexport interface BeginRecoverDeletedSecretOptions extends SecretPollerOptions {}\n\n/**\n * Options for {@link setSecret}.\n */\nexport interface SetSecretOptions extends coreHttp.OperationOptions {\n  /**\n   * Application specific metadata in the form of key-value pairs.\n   */\n  tags?: { [propertyName: string]: string };\n  /**\n   * Type of the secret value such as a password.\n   */\n  contentType?: string;\n  /**\n   * Determines whether the object is enabled.\n   */\n  enabled?: boolean;\n  /**\n   * Not before date in UTC.\n   */\n  readonly notBefore?: Date;\n  /**\n   * Expiry date in UTC.\n   */\n  readonly expiresOn?: Date;\n}\n\n/**\n * Options for {@link updateSecretProperties}.\n */\nexport interface UpdateSecretPropertiesOptions extends coreHttp.OperationOptions {\n  /**\n   * Type of the secret value such as a password.\n   */\n  contentType?: string;\n  /**\n   * Determines whether the object is enabled.\n   */\n  enabled?: boolean;\n  /**\n   * Not before date in UTC.\n   */\n  readonly notBefore?: Date;\n  /**\n   * Expiry date in UTC.\n   */\n  readonly expiresOn?: Date;\n  /**\n   * Application specific metadata in the form of key-value pairs.\n   */\n  tags?: { [propertyName: string]: string };\n}\n\n/**\n * Options for {@link getSecret}.\n */\nexport interface GetSecretOptions extends coreHttp.OperationOptions {\n  /**\n   * The version of the secret to retrieve. If not\n   * specified the latest version of the secret will be retrieved.\n   */\n  version?: string;\n}\n\n/**\n * Options for {@link getDeletedSecret}.\n */\nexport interface GetDeletedSecretOptions extends coreHttp.OperationOptions {}\n\n/**\n * Options for {@link purgeDeletedSecret}.\n */\nexport interface PurgeDeletedSecretOptions extends coreHttp.OperationOptions {}\n\n/**\n * Options for {@link backupSecretOptions}.\n */\nexport interface BackupSecretOptions extends coreHttp.OperationOptions {}\n\n/**\n * Options for {@link restoreSecretBackup}.\n */\nexport interface RestoreSecretBackupOptions extends coreHttp.OperationOptions {}\n\n/**\n * @internal\n * Options for {@link recoverDeletedSecret}.\n */\nexport interface RecoverDeletedSecretOptions extends coreHttp.OperationOptions {}\n\n/**\n * @internal\n * Options for {@link deleteSecret}.\n */\nexport interface DeleteSecretOptions extends coreHttp.OperationOptions {}\n\n/**\n * Options for {@link listPropertiesOfSecretVersions}.\n */\nexport interface ListPropertiesOfSecretVersionsOptions extends coreHttp.OperationOptions {}\n\n/**\n * Options for {@link listPropertiesOfSecrets}.\n */\nexport interface ListPropertiesOfSecretsOptions extends coreHttp.OperationOptions {}\n\n/**\n * Options for {@link listDeletedSecrets}.\n */\nexport interface ListDeletedSecretsOptions extends coreHttp.OperationOptions {}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/* eslint @typescript-eslint/member-ordering: 0 */\n/// <reference lib=\"esnext.asynciterable\" />\n\nimport {\n  TokenCredential,\n  isTokenCredential,\n  signingPolicy,\n  PipelineOptions,\n  createPipelineFromOptions\n} from \"@azure/core-http\";\n\nimport { logger } from \"./log\";\n\nimport \"@azure/core-paging\";\nimport { PageSettings, PagedAsyncIterableIterator } from \"@azure/core-paging\";\nimport { PollerLike, PollOperationState } from \"@azure/core-lro\";\nimport {\n  DeletionRecoveryLevel,\n  KnownDeletionRecoveryLevel,\n  KeyVaultClientGetSecretsOptionalParams,\n  SecretBundle,\n  DeletedSecretBundle\n} from \"./generated/models\";\nimport { KeyVaultClient } from \"./generated/keyVaultClient\";\nimport { SDK_VERSION } from \"./constants\";\nimport { challengeBasedAuthenticationPolicy } from \"../../keyvault-common/src\";\n\nimport { DeleteSecretPoller } from \"./lro/delete/poller\";\nimport { RecoverDeletedSecretPoller } from \"./lro/recover/poller\";\n\nimport {\n  KeyVaultSecret,\n  DeletedSecret,\n  SecretPollerOptions,\n  BeginDeleteSecretOptions,\n  BeginRecoverDeletedSecretOptions,\n  SetSecretOptions,\n  UpdateSecretPropertiesOptions,\n  GetSecretOptions,\n  GetDeletedSecretOptions,\n  PurgeDeletedSecretOptions,\n  BackupSecretOptions,\n  RestoreSecretBackupOptions,\n  ListPropertiesOfSecretVersionsOptions,\n  ListPropertiesOfSecretsOptions,\n  ListDeletedSecretsOptions,\n  SecretProperties,\n  SecretClientOptions,\n  LATEST_API_VERSION\n} from \"./secretsModels\";\nimport { KeyVaultSecretIdentifier, parseKeyVaultSecretIdentifier } from \"./identifier\";\nimport { getSecretFromSecretBundle } from \"./transformations\";\nimport { createTraceFunction } from \"../../keyvault-common/src\";\n\nexport {\n  SecretClientOptions,\n  DeletedSecret,\n  DeletionRecoveryLevel,\n  KnownDeletionRecoveryLevel,\n  GetSecretOptions,\n  PipelineOptions,\n  GetDeletedSecretOptions,\n  PurgeDeletedSecretOptions,\n  BackupSecretOptions,\n  RestoreSecretBackupOptions,\n  ListPropertiesOfSecretVersionsOptions,\n  ListPropertiesOfSecretsOptions,\n  ListDeletedSecretsOptions,\n  PagedAsyncIterableIterator,\n  PageSettings,\n  KeyVaultSecretIdentifier,\n  parseKeyVaultSecretIdentifier,\n  PollerLike,\n  PollOperationState,\n  KeyVaultSecret,\n  SecretProperties,\n  SecretPollerOptions,\n  BeginDeleteSecretOptions,\n  BeginRecoverDeletedSecretOptions,\n  SetSecretOptions,\n  UpdateSecretPropertiesOptions,\n  logger\n};\n\nconst withTrace = createTraceFunction(\"Azure.KeyVault.Secrets.SecretClient\");\n\n/**\n * The SecretClient provides methods to manage {@link KeyVaultSecret} in\n * the Azure Key Vault. The client supports creating, retrieving, updating,\n * deleting, purging, backing up, restoring and listing KeyVaultSecrets. The\n * client also supports listing {@link DeletedSecret} for a soft-delete enabled Azure\n * Key Vault.\n */\nexport class SecretClient {\n  /**\n   * The base URL to the vault\n   */\n  public readonly vaultUrl: string;\n\n  /**\n   * @internal\n   * @hidden\n   * A reference to the auto-generated KeyVault HTTP client.\n   */\n  private readonly client: KeyVaultClient;\n\n  /**\n   * Creates an instance of SecretClient.\n   *\n   * Example usage:\n   * ```ts\n   * import { SecretClient } from \"@azure/keyvault-secrets\";\n   * import { DefaultAzureCredential } from \"@azure/identity\";\n   *\n   * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;\n   * let credentials = new DefaultAzureCredential();\n   *\n   * let client = new SecretClient(vaultUrl, credentials);\n   * ```\n   * @param vaultUrl - The base URL to the vault.\n   * @param credential - An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the \\@azure/identity package to create a credential that suits your needs.\n   * @param pipelineOptions - Pipeline options used to configure Key Vault API requests.\n   *                          Omit this parameter to use the default pipeline configuration.\n   */\n  constructor(\n    vaultUrl: string,\n    credential: TokenCredential,\n    pipelineOptions: SecretClientOptions = {}\n  ) {\n    this.vaultUrl = vaultUrl;\n\n    const libInfo = `azsdk-js-keyvault-secrets/${SDK_VERSION}`;\n\n    const userAgentOptions = pipelineOptions.userAgentOptions;\n\n    pipelineOptions.userAgentOptions = {\n      userAgentPrefix:\n        userAgentOptions && userAgentOptions.userAgentPrefix\n          ? `${userAgentOptions.userAgentPrefix} ${libInfo}`\n          : libInfo\n    };\n\n    const authPolicy = isTokenCredential(credential)\n      ? challengeBasedAuthenticationPolicy(credential)\n      : signingPolicy(credential);\n\n    const internalPipelineOptions = {\n      ...pipelineOptions,\n      loggingOptions: {\n        logger: logger.info,\n        allowedHeaderNames: [\n          \"x-ms-keyvault-region\",\n          \"x-ms-keyvault-network-info\",\n          \"x-ms-keyvault-service-version\"\n        ]\n      }\n    };\n\n    this.client = new KeyVaultClient(\n      pipelineOptions.serviceVersion || LATEST_API_VERSION,\n      createPipelineFromOptions(internalPipelineOptions, authPolicy)\n    );\n  }\n\n  /**\n   * The setSecret method adds a secret or secret version to the Azure Key Vault. If the named secret\n   * already exists, Azure Key Vault creates a new version of that secret.\n   * This operation requires the secrets/set permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * await client.setSecret(\"MySecretName\", \"ABC123\");\n   * ```\n   * Adds a secret in a specified key vault.\n   * @param secretName - The name of the secret.\n   * @param value - The value of the secret.\n   * @param options - The optional parameters.\n   */\n  public setSecret(\n    secretName: string,\n    value: string,\n    options: SetSecretOptions = {}\n  ): Promise<KeyVaultSecret> {\n    let unflattenedOptions = {};\n\n    if (options) {\n      const { enabled, notBefore, expiresOn: expires, ...remainingOptions } = options;\n      unflattenedOptions = {\n        ...remainingOptions,\n        secretAttributes: {\n          enabled,\n          notBefore,\n          expires\n        }\n      };\n    }\n    return withTrace(\"setSecret\", unflattenedOptions, async (updatedOptions) => {\n      const response = await this.client.setSecret(\n        this.vaultUrl,\n        secretName,\n        value,\n        updatedOptions\n      );\n      return getSecretFromSecretBundle(response);\n    });\n  }\n\n  /**\n   * Deletes a secret stored in Azure Key Vault.\n   * This function returns a Long Running Operation poller that allows you to wait indefinitely until the secret is deleted.\n   *\n   * This operation requires the secrets/delete permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new SecretClient(url, credentials);\n   * await client.setSecret(\"MySecretName\", \"ABC123\");\n   *\n   * const deletePoller = await client.beginDeleteSecret(\"MySecretName\");\n   *\n   * // Serializing the poller\n   * const serialized = deletePoller.toString();\n   *\n   * // A new poller can be created with:\n   * // const newPoller = await client.beginDeleteSecret(\"MySecretName\", { resumeFrom: serialized });\n   *\n   * // Waiting until it's done\n   * const deletedSecret = await deletePoller.pollUntilDone();\n   * console.log(deletedSecret);\n   * ```\n   * Deletes a secret from a specified key vault.\n   * @param secretName - The name of the secret.\n   * @param options - The optional parameters.\n   */\n  public async beginDeleteSecret(\n    name: string,\n    options: BeginDeleteSecretOptions = {}\n  ): Promise<PollerLike<PollOperationState<DeletedSecret>, DeletedSecret>> {\n    const poller = new DeleteSecretPoller({\n      name,\n      client: this.client,\n      vaultUrl: this.vaultUrl,\n      ...options,\n      operationOptions: options\n    });\n    // This will initialize the poller's operation (the deletion of the secret).\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * The updateSecret method changes specified attributes of an existing stored secret. Properties that\n   * are not specified in the request are left unchanged. The value of a secret itself cannot be\n   * changed. This operation requires the secrets/set permission.\n   *\n   * Example usage:\n   * ```ts\n   * let secretName = \"MySecretName\";\n   * let client = new SecretClient(url, credentials);\n   * let secret = await client.getSecret(secretName);\n   * await client.updateSecretProperties(secretName, secret.properties.version, { enabled: false });\n   * ```\n   * Updates the attributes associated with a specified secret in a given key vault.\n   * @param secretName - The name of the secret.\n   * @param secretVersion - The version of the secret.\n   * @param options - The optional parameters.\n   */\n  public async updateSecretProperties(\n    secretName: string,\n    secretVersion: string,\n    options: UpdateSecretPropertiesOptions = {}\n  ): Promise<SecretProperties> {\n    let unflattenedOptions = {};\n    if (options) {\n      const { enabled, notBefore, expiresOn: expires, ...remainingOptions } = options;\n      unflattenedOptions = {\n        ...remainingOptions,\n        secretAttributes: {\n          enabled,\n          notBefore,\n          expires\n        }\n      };\n    }\n\n    return withTrace(\"updateSecretProperties\", unflattenedOptions, async (updatedOptions) => {\n      const response = await this.client.updateSecret(\n        this.vaultUrl,\n        secretName,\n        secretVersion,\n        updatedOptions\n      );\n      return getSecretFromSecretBundle(response).properties;\n    });\n  }\n\n  /**\n   * The getSecret method is applicable to any secret stored in Azure Key Vault. This operation requires\n   * the secrets/get permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * let secret = await client.getSecret(\"MySecretName\");\n   * ```\n   * Get a specified secret from a given key vault.\n   * @param secretName - The name of the secret.\n   * @param options - The optional parameters.\n   */\n  public getSecret(secretName: string, options: GetSecretOptions = {}): Promise<KeyVaultSecret> {\n    return withTrace(\"getSecret\", options, async (updatedOptions) => {\n      const response = await this.client.getSecret(\n        this.vaultUrl,\n        secretName,\n        options && options.version ? options.version : \"\",\n        updatedOptions\n      );\n      return getSecretFromSecretBundle(response);\n    });\n  }\n\n  /**\n   * The getDeletedSecret method returns the specified deleted secret along with its attributes.\n   * This operation requires the secrets/get permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * await client.getDeletedSecret(\"MyDeletedSecret\");\n   * ```\n   * Gets the specified deleted secret.\n   * @param secretName - The name of the secret.\n   * @param options - The optional parameters.\n   */\n  public getDeletedSecret(\n    secretName: string,\n    options: GetDeletedSecretOptions = {}\n  ): Promise<DeletedSecret> {\n    return withTrace(\"getDeletedSecret\", options, async (updatedOptions) => {\n      const response = await this.client.getDeletedSecret(\n        this.vaultUrl,\n        secretName,\n        updatedOptions\n      );\n      return getSecretFromSecretBundle(response);\n    });\n  }\n\n  /**\n   * The purge deleted secret operation removes the secret permanently, without the possibility of\n   * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation\n   * requires the secrets/purge permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new SecretClient(url, credentials);\n   * const deletePoller = await client.beginDeleteSecret(\"MySecretName\");\n   * await deletePoller.pollUntilDone();\n   * await client.purgeDeletedSecret(\"MySecretName\");\n   * ```\n   * Permanently deletes the specified secret.\n   * @param secretName - The name of the secret.\n   * @param options - The optional parameters.\n   */\n  public purgeDeletedSecret(\n    secretName: string,\n    options: PurgeDeletedSecretOptions = {}\n  ): Promise<void> {\n    return withTrace(\"purgeDeletedSecret\", options, async (updatedOptions) => {\n      await this.client.purgeDeletedSecret(this.vaultUrl, secretName, updatedOptions);\n    });\n  }\n\n  /**\n   * Recovers the deleted secret in the specified vault.\n   * This function returns a Long Running Operation poller that allows you to wait indefinitely until the secret is recovered.\n   *\n   * This operation requires the secrets/recover permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new SecretClient(url, credentials);\n   * await client.setSecret(\"MySecretName\", \"ABC123\");\n   *\n   * const deletePoller = await client.beginDeleteSecret(\"MySecretName\");\n   * await deletePoller.pollUntilDone();\n   *\n   * const recoverPoller = await client.beginRecoverDeletedSecret(\"MySecretName\");\n   *\n   * // Serializing the poller\n   * const serialized = recoverPoller.toString();\n   *\n   * // A new poller can be created with:\n   * // const newPoller = await client.beginRecoverDeletedSecret(\"MySecretName\", { resumeFrom: serialized });\n   *\n   * // Waiting until it's done\n   * const deletedSecret = await recoverPoller.pollUntilDone();\n   * console.log(deletedSecret);\n   * ```\n   * Recovers the deleted secret to the latest version.\n   * @param secretName - The name of the deleted secret.\n   * @param options - The optional parameters.\n   */\n  public async beginRecoverDeletedSecret(\n    name: string,\n    options: BeginRecoverDeletedSecretOptions = {}\n  ): Promise<PollerLike<PollOperationState<SecretProperties>, SecretProperties>> {\n    const poller = new RecoverDeletedSecretPoller({\n      name,\n      client: this.client,\n      vaultUrl: this.vaultUrl,\n      ...options,\n      operationOptions: options\n    });\n\n    // This will initialize the poller's operation (the recovery of the deleted secret).\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Requests that a backup of the specified secret be downloaded to the client. All versions of the\n   * secret will be downloaded. This operation requires the secrets/backup permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * let backupResult = await client.backupSecret(\"MySecretName\");\n   * ```\n   * Backs up the specified secret.\n   * @param secretName - The name of the secret.\n   * @param options - The optional parameters.\n   */\n  public backupSecret(\n    secretName: string,\n    options: BackupSecretOptions = {}\n  ): Promise<Uint8Array | undefined> {\n    return withTrace(\"backupSecret\", options, async (updatedOptions) => {\n      const response = await this.client.backupSecret(this.vaultUrl, secretName, updatedOptions);\n\n      return response.value;\n    });\n  }\n\n  /**\n   * Restores a backed up secret, and all its versions, to a vault. This operation requires the\n   * secrets/restore permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * let mySecretBundle = await client.backupSecret(\"MySecretName\");\n   * // ...\n   * await client.restoreSecretBackup(mySecretBundle);\n   * ```\n   * Restores a backed up secret to a vault.\n   * @param secretBundleBackup - The backup blob associated with a secret bundle.\n   * @param options - The optional parameters.\n   */\n  public restoreSecretBackup(\n    secretBundleBackup: Uint8Array,\n    options: RestoreSecretBackupOptions = {}\n  ): Promise<SecretProperties> {\n    return withTrace(\"restoreSecretBackup\", options, async (updatedOptions) => {\n      const response = await this.client.restoreSecret(\n        this.vaultUrl,\n        secretBundleBackup,\n        updatedOptions\n      );\n      return getSecretFromSecretBundle(response).properties;\n    });\n  }\n\n  /**\n   * @internal\n   * @hidden\n   * Deals with the pagination of {@link listPropertiesOfSecretVersions}.\n   * @param name - The name of the KeyVault Secret.\n   * @param continuationState - An object that indicates the position of the paginated request.\n   * @param options - Optional parameters for the underlying HTTP request.\n   */\n  private async *listPropertiesOfSecretVersionsPage(\n    secretName: string,\n    continuationState: PageSettings,\n    options: ListPropertiesOfSecretVersionsOptions = {}\n  ): AsyncIterableIterator<SecretProperties[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: KeyVaultClientGetSecretsOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options\n      };\n      const currentSetResponse = await withTrace(\n        \"listPropertiesOfSecretVersions\",\n        optionsComplete,\n        (updatedOptions) => this.client.getSecretVersions(this.vaultUrl, secretName, updatedOptions)\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(\n          (bundle: SecretBundle | DeletedSecretBundle) =>\n            getSecretFromSecretBundle(bundle).properties\n        );\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await withTrace(\n        \"listPropertiesOfSecretVersions\",\n        options,\n        (updatedOptions) =>\n          this.client.getSecretVersions(\n            continuationState.continuationToken!,\n            secretName,\n            updatedOptions\n          )\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(\n          (bundle: SecretBundle | DeletedSecretBundle) =>\n            getSecretFromSecretBundle(bundle).properties\n        );\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @internal\n   * @hidden\n   * Deals with the iteration of all the available results of {@link listPropertiesOfSecretVersions}.\n   * @param name - The name of the KeyVault Secret.\n   * @param options - Optional parameters for the underlying HTTP request.\n   */\n  private async *listPropertiesOfSecretVersionsAll(\n    secretName: string,\n    options: ListPropertiesOfSecretVersionsOptions = {}\n  ): AsyncIterableIterator<SecretProperties> {\n    const f = {};\n\n    for await (const page of this.listPropertiesOfSecretVersionsPage(secretName, f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates all versions of the given secret in the vault. The full secret identifier and attributes are provided\n   * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * for await (const secretProperties of client.listPropertiesOfSecretVersions(\"MySecretName\")) {\n   *   const secret = await client.getSecret(secretProperties.name);\n   *   console.log(\"secret version: \", secret);\n   * }\n   * ```\n   * @param secretName - Name of the secret to fetch versions for.\n   * @param options - The optional parameters.\n   */\n  public listPropertiesOfSecretVersions(\n    secretName: string,\n    options: ListPropertiesOfSecretVersionsOptions = {}\n  ): PagedAsyncIterableIterator<SecretProperties> {\n    const iter = this.listPropertiesOfSecretVersionsAll(secretName, options);\n\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) =>\n        this.listPropertiesOfSecretVersionsPage(secretName, settings, options)\n    };\n  }\n\n  /**\n   * @internal\n   * @hidden\n   * Deals with the pagination of {@link listPropertiesOfSecrets}.\n   * @param continuationState - An object that indicates the position of the paginated request.\n   * @param options - Optional parameters for the underlying HTTP request.\n   */\n  private async *listPropertiesOfSecretsPage(\n    continuationState: PageSettings,\n    options: ListPropertiesOfSecretsOptions = {}\n  ): AsyncIterableIterator<SecretProperties[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: KeyVaultClientGetSecretsOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options\n      };\n      const currentSetResponse = await withTrace(\n        \"listPropertiesOfSecrets\",\n        optionsComplete,\n        (updatedOptions) => this.client.getSecrets(this.vaultUrl, updatedOptions)\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(\n          (bundle: SecretBundle | DeletedSecretBundle) =>\n            getSecretFromSecretBundle(bundle).properties\n        );\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await withTrace(\n        \"listPropertiesOfSecrets\",\n        options,\n        (updatedOptions) =>\n          this.client.getSecrets(continuationState.continuationToken!, updatedOptions)\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(\n          (bundle: SecretBundle | DeletedSecretBundle) =>\n            getSecretFromSecretBundle(bundle).properties\n        );\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @internal\n   * @hidden\n   * Deals with the iteration of all the available results of {@link listPropertiesOfSecrets}.\n   * @param options - Optional parameters for the underlying HTTP request.\n   */\n  private async *listPropertiesOfSecretsAll(\n    options: ListPropertiesOfSecretsOptions = {}\n  ): AsyncIterableIterator<SecretProperties> {\n    const f = {};\n\n    for await (const page of this.listPropertiesOfSecretsPage(f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates the latest version of all secrets in the vault.  The full secret identifier and attributes are provided\n   * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * for await (const secretProperties of client.listPropertiesOfSecrets()) {\n   *   const secret = await client.getSecret(secretProperties.name);\n   *   console.log(\"secret: \", secret);\n   * }\n   * ```\n   * List all secrets in the vault.\n   * @param options - The optional parameters.\n   */\n  public listPropertiesOfSecrets(\n    options: ListPropertiesOfSecretsOptions = {}\n  ): PagedAsyncIterableIterator<SecretProperties> {\n    const iter = this.listPropertiesOfSecretsAll(options);\n\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) => this.listPropertiesOfSecretsPage(settings, options)\n    };\n  }\n\n  /**\n   * @internal\n   * @hidden\n   * Deals with the pagination of {@link listDeletedSecrets}.\n   * @param continuationState - An object that indicates the position of the paginated request.\n   * @param options - Optional parameters for the underlying HTTP request.\n   */\n  private async *listDeletedSecretsPage(\n    continuationState: PageSettings,\n    options: ListDeletedSecretsOptions = {}\n  ): AsyncIterableIterator<DeletedSecret[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: KeyVaultClientGetSecretsOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options\n      };\n      const currentSetResponse = await withTrace(\n        \"listDeletedSecrets\",\n        optionsComplete,\n        (updatedOptions) => this.client.getDeletedSecrets(this.vaultUrl, updatedOptions)\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map((bundle: SecretBundle | DeletedSecretBundle) =>\n          getSecretFromSecretBundle(bundle)\n        );\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await withTrace(\"lisDeletedSecrets\", options, (updatedOptions) =>\n        this.client.getDeletedSecrets(continuationState.continuationToken!, updatedOptions)\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map((bundle: SecretBundle | DeletedSecretBundle) =>\n          getSecretFromSecretBundle(bundle)\n        );\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @internal\n   * @hidden\n   * Deals with the iteration of all the available results of {@link listDeletedSecrets}.\n   * @param options - Optional parameters for the underlying HTTP request.\n   */\n  private async *listDeletedSecretsAll(\n    options: ListDeletedSecretsOptions = {}\n  ): AsyncIterableIterator<DeletedSecret> {\n    const f = {};\n\n    for await (const page of this.listDeletedSecretsPage(f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates the deleted secrets in the vault.  The full secret identifier and attributes are provided\n   * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * for await (const deletedSecret of client.listDeletedSecrets()) {\n   *   console.log(\"deleted secret: \", deletedSecret);\n   * }\n   * ```\n   * List all secrets in the vault.\n   * @param options - The optional parameters.\n   */\n  public listDeletedSecrets(\n    options: ListDeletedSecretsOptions = {}\n  ): PagedAsyncIterableIterator<DeletedSecret> {\n    const iter = this.listDeletedSecretsAll(options);\n\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) => this.listDeletedSecretsPage(settings, options)\n    };\n  }\n}\n"],"names":["createClientLogger","coreHttp.ServiceClient","coreHttp.getDefaultUserAgentValue","coreHttp.operationOptionsToRequestOptionsBase","coreHttp.Serializer","Mappers.SecretBundle","Mappers.KeyVaultError","Mappers.SecretSetParameters","Parameters.apiVersion","Parameters.vaultBaseUrl","Parameters.secretName","Parameters.contentType","Parameters.accept","Mappers.DeletedSecretBundle","Parameters.secretName1","Mappers.SecretUpdateParameters","Parameters.secretVersion","Mappers.SecretListResult","Parameters.maxresults","Mappers.DeletedSecretListResult","Mappers.BackupSecretResult","Mappers.SecretRestoreParameters","Parameters.nextLink","ExpiringAccessTokenCache","BaseRequestPolicy","Constants","url.parse","createSpanFunction","SpanStatusCode","Poller","delay","withTrace","isTokenCredential","signingPolicy","createPipelineFromOptions","__asyncValues"],"mappings":"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"}