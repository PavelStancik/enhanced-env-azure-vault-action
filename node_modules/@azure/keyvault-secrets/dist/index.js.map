{"version":3,"file":"index.js","sources":["../src/log.ts","../src/generated/models/mappers.ts","../src/generated/models/parameters.ts","../src/generated/keyVaultClientContext.ts","../src/generated/keyVaultClient.ts","../src/generated/utils/constants.ts","../../keyvault-common/src/challengeBasedAuthenticationPolicy.ts","../src/lro/delete/operation.ts","../src/lro/delete/poller.ts","../src/lro/recover/operation.ts","../src/lro/recover/poller.ts","../src/secretsModels.ts","../src/generated/utils.ts","../src/index.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createClientLogger } from \"@azure/logger\";\n\n/**\n * The @azure/logger configuration for this package.\n */\nexport const logger = createClientLogger(\"keyvault-secrets\");\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport * as coreHttp from \"@azure/core-http\";\n\n\nexport const Attributes: coreHttp.CompositeMapper = {\n  serializedName: \"Attributes\",\n  type: {\n    name: \"Composite\",\n    className: \"Attributes\",\n    modelProperties: {\n      enabled: {\n        serializedName: \"enabled\",\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      notBefore: {\n        serializedName: \"nbf\",\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      expires: {\n        serializedName: \"exp\",\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      created: {\n        readOnly: true,\n        serializedName: \"created\",\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      updated: {\n        readOnly: true,\n        serializedName: \"updated\",\n        type: {\n          name: \"UnixTime\"\n        }\n      }\n    }\n  }\n};\n\nexport const SecretAttributes: coreHttp.CompositeMapper = {\n  serializedName: \"SecretAttributes\",\n  type: {\n    name: \"Composite\",\n    className: \"SecretAttributes\",\n    modelProperties: {\n      ...Attributes.type.modelProperties,\n      recoverableDays: {\n        readOnly: true,\n        serializedName: \"recoverableDays\",\n        type: {\n          name: \"Number\"\n        }\n      },\n      recoveryLevel: {\n        nullable: false,\n        readOnly: true,\n        serializedName: \"recoveryLevel\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const SecretBundle: coreHttp.CompositeMapper = {\n  serializedName: \"SecretBundle\",\n  type: {\n    name: \"Composite\",\n    className: \"SecretBundle\",\n    modelProperties: {\n      value: {\n        serializedName: \"value\",\n        type: {\n          name: \"String\"\n        }\n      },\n      id: {\n        serializedName: \"id\",\n        type: {\n          name: \"String\"\n        }\n      },\n      contentType: {\n        serializedName: \"contentType\",\n        type: {\n          name: \"String\"\n        }\n      },\n      attributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"SecretAttributes\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      },\n      kid: {\n        readOnly: true,\n        serializedName: \"kid\",\n        type: {\n          name: \"String\"\n        }\n      },\n      managed: {\n        readOnly: true,\n        serializedName: \"managed\",\n        type: {\n          name: \"Boolean\"\n        }\n      }\n    }\n  }\n};\n\nexport const SecretItem: coreHttp.CompositeMapper = {\n  serializedName: \"SecretItem\",\n  type: {\n    name: \"Composite\",\n    className: \"SecretItem\",\n    modelProperties: {\n      id: {\n        serializedName: \"id\",\n        type: {\n          name: \"String\"\n        }\n      },\n      attributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"SecretAttributes\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      },\n      contentType: {\n        serializedName: \"contentType\",\n        type: {\n          name: \"String\"\n        }\n      },\n      managed: {\n        readOnly: true,\n        serializedName: \"managed\",\n        type: {\n          name: \"Boolean\"\n        }\n      }\n    }\n  }\n};\n\nexport const DeletedSecretBundle: coreHttp.CompositeMapper = {\n  serializedName: \"DeletedSecretBundle\",\n  type: {\n    name: \"Composite\",\n    className: \"DeletedSecretBundle\",\n    modelProperties: {\n      ...SecretBundle.type.modelProperties,\n      recoveryId: {\n        serializedName: \"recoveryId\",\n        type: {\n          name: \"String\"\n        }\n      },\n      scheduledPurgeDate: {\n        readOnly: true,\n        serializedName: \"scheduledPurgeDate\",\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      deletedDate: {\n        readOnly: true,\n        serializedName: \"deletedDate\",\n        type: {\n          name: \"UnixTime\"\n        }\n      }\n    }\n  }\n};\n\nexport const DeletedSecretItem: coreHttp.CompositeMapper = {\n  serializedName: \"DeletedSecretItem\",\n  type: {\n    name: \"Composite\",\n    className: \"DeletedSecretItem\",\n    modelProperties: {\n      ...SecretItem.type.modelProperties,\n      recoveryId: {\n        serializedName: \"recoveryId\",\n        type: {\n          name: \"String\"\n        }\n      },\n      scheduledPurgeDate: {\n        readOnly: true,\n        serializedName: \"scheduledPurgeDate\",\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      deletedDate: {\n        readOnly: true,\n        serializedName: \"deletedDate\",\n        type: {\n          name: \"UnixTime\"\n        }\n      }\n    }\n  }\n};\n\nexport const SecretRestoreParameters: coreHttp.CompositeMapper = {\n  serializedName: \"SecretRestoreParameters\",\n  type: {\n    name: \"Composite\",\n    className: \"SecretRestoreParameters\",\n    modelProperties: {\n      secretBundleBackup: {\n        required: true,\n        serializedName: \"value\",\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const SecretProperties: coreHttp.CompositeMapper = {\n  serializedName: \"SecretProperties\",\n  type: {\n    name: \"Composite\",\n    className: \"SecretProperties\",\n    modelProperties: {\n      contentType: {\n        serializedName: \"contentType\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const SecretSetParameters: coreHttp.CompositeMapper = {\n  serializedName: \"SecretSetParameters\",\n  type: {\n    name: \"Composite\",\n    className: \"SecretSetParameters\",\n    modelProperties: {\n      value: {\n        required: true,\n        serializedName: \"value\",\n        type: {\n          name: \"String\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      },\n      contentType: {\n        serializedName: \"contentType\",\n        type: {\n          name: \"String\"\n        }\n      },\n      secretAttributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"SecretAttributes\"\n        }\n      }\n    }\n  }\n};\n\nexport const SecretUpdateParameters: coreHttp.CompositeMapper = {\n  serializedName: \"SecretUpdateParameters\",\n  type: {\n    name: \"Composite\",\n    className: \"SecretUpdateParameters\",\n    modelProperties: {\n      contentType: {\n        serializedName: \"contentType\",\n        type: {\n          name: \"String\"\n        }\n      },\n      secretAttributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"SecretAttributes\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const SecretListResult: coreHttp.CompositeMapper = {\n  serializedName: \"SecretListResult\",\n  type: {\n    name: \"Composite\",\n    className: \"SecretListResult\",\n    modelProperties: {\n      value: {\n        readOnly: true,\n        serializedName: \"value\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"SecretItem\"\n            }\n          }\n        }\n      },\n      nextLink: {\n        readOnly: true,\n        serializedName: \"nextLink\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const DeletedSecretListResult: coreHttp.CompositeMapper = {\n  serializedName: \"DeletedSecretListResult\",\n  type: {\n    name: \"Composite\",\n    className: \"DeletedSecretListResult\",\n    modelProperties: {\n      value: {\n        readOnly: true,\n        serializedName: \"value\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DeletedSecretItem\"\n            }\n          }\n        }\n      },\n      nextLink: {\n        readOnly: true,\n        serializedName: \"nextLink\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const BackupSecretResult: coreHttp.CompositeMapper = {\n  serializedName: \"BackupSecretResult\",\n  type: {\n    name: \"Composite\",\n    className: \"BackupSecretResult\",\n    modelProperties: {\n      value: {\n        readOnly: true,\n        serializedName: \"value\",\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const ErrorModel: coreHttp.CompositeMapper = {\n  serializedName: \"Error\",\n  type: {\n    name: \"Composite\",\n    className: \"ErrorModel\",\n    modelProperties: {\n      code: {\n        readOnly: true,\n        serializedName: \"code\",\n        type: {\n          name: \"String\"\n        }\n      },\n      message: {\n        readOnly: true,\n        serializedName: \"message\",\n        type: {\n          name: \"String\"\n        }\n      },\n      innerError: {\n        readOnly: true,\n        serializedName: \"innererror\",\n        type: {\n          name: \"Composite\",\n          className: \"ErrorModel\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyVaultError: coreHttp.CompositeMapper = {\n  serializedName: \"KeyVaultError\",\n  type: {\n    name: \"Composite\",\n    className: \"KeyVaultError\",\n    modelProperties: {\n      error: {\n        readOnly: true,\n        serializedName: \"error\",\n        type: {\n          name: \"Composite\",\n          className: \"ErrorModel\"\n        }\n      }\n    }\n  }\n};\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is\n * regenerated.\n */\n\nimport * as coreHttp from \"@azure/core-http\";\n\nexport const apiVersion: coreHttp.OperationQueryParameter = {\n  parameterPath: \"apiVersion\",\n  mapper: {\n    required: true,\n    serializedName: \"api-version\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\nexport const maxresults: coreHttp.OperationQueryParameter = {\n  parameterPath: [\n    \"options\",\n    \"maxresults\"\n  ],\n  mapper: {\n    serializedName: \"maxresults\",\n    constraints: {\n      InclusiveMaximum: 25,\n      InclusiveMinimum: 1\n    },\n    type: {\n      name: \"Number\"\n    }\n  }\n};\nexport const secretName0: coreHttp.OperationURLParameter = {\n  parameterPath: \"secretName\",\n  mapper: {\n    required: true,\n    serializedName: \"secret-name\",\n    constraints: {\n      Pattern: /^[0-9a-zA-Z-]+$/\n    },\n    type: {\n      name: \"String\"\n    }\n  }\n};\nexport const secretName1: coreHttp.OperationURLParameter = {\n  parameterPath: \"secretName\",\n  mapper: {\n    required: true,\n    serializedName: \"secret-name\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\nexport const secretVersion: coreHttp.OperationURLParameter = {\n  parameterPath: \"secretVersion\",\n  mapper: {\n    required: true,\n    serializedName: \"secret-version\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\nexport const vaultBaseUrl: coreHttp.OperationURLParameter = {\n  parameterPath: \"vaultBaseUrl\",\n  mapper: {\n    required: true,\n    serializedName: \"vaultBaseUrl\",\n    defaultValue: '',\n    type: {\n      name: \"String\"\n    }\n  },\n  skipEncoding: true\n};\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is\n * regenerated.\n */\n\nimport * as coreHttp from \"@azure/core-http\";\n\nconst packageName = \"@azure/keyvault-secrets\";\nexport const packageVersion = \"4.1.0\";\n\nexport class KeyVaultClientContext extends coreHttp.ServiceClient {\n  apiVersion: string;\n\n  /**\n   * Initializes a new instance of the KeyVaultClientContext class.\n   * @param apiVersion Client API version.\n   * @param [options] The parameter options\n   */\n  constructor(apiVersion: string, options?: coreHttp.ServiceClientOptions) {\n    if (apiVersion == undefined) {\n      throw new Error(\"'apiVersion' cannot be null.\");\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    if (!options.userAgent) {\n      const defaultUserAgent = coreHttp.getDefaultUserAgentValue();\n      options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;\n    }\n\n    super(undefined, options);\n\n    this.baseUri = \"{vaultBaseUrl}\";\n    this.requestContentType = \"application/json; charset=utf-8\";\n    this.apiVersion = apiVersion;\n  }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is\n * regenerated.\n */\n\nimport * as coreHttp from \"@azure/core-http\";\nimport * as Models from \"./models\";\nimport * as Mappers from \"./models/mappers\";\nimport * as Parameters from \"./models/parameters\";\nimport { KeyVaultClientContext } from \"./keyVaultClientContext\";\n\nclass KeyVaultClient extends KeyVaultClientContext {\n  /**\n   * Initializes a new instance of the KeyVaultClient class.\n   * @param apiVersion Client API version.\n   * @param [options] The parameter options\n   */\n  constructor(apiVersion: string, options?: coreHttp.ServiceClientOptions) {\n    super(apiVersion, options);\n  }\n\n  /**\n   * The SET operation adds a secret to the Azure Key Vault. If the named secret already exists,\n   * Azure Key Vault creates a new version of that secret. This operation requires the secrets/set\n   * permission.\n   * @summary Sets a secret in a specified key vault.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param value The value of the secret.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.SetSecretResponse>\n   */\n  setSecret(vaultBaseUrl: string, secretName: string, value: string, options?: Models.KeyVaultClientSetSecretOptionalParams): Promise<Models.SetSecretResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param value The value of the secret.\n   * @param callback The callback\n   */\n  setSecret(vaultBaseUrl: string, secretName: string, value: string, callback: coreHttp.ServiceCallback<Models.SecretBundle>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param value The value of the secret.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  setSecret(vaultBaseUrl: string, secretName: string, value: string, options: Models.KeyVaultClientSetSecretOptionalParams, callback: coreHttp.ServiceCallback<Models.SecretBundle>): void;\n  setSecret(vaultBaseUrl: string, secretName: string, value: string, options?: Models.KeyVaultClientSetSecretOptionalParams | coreHttp.ServiceCallback<Models.SecretBundle>, callback?: coreHttp.ServiceCallback<Models.SecretBundle>): Promise<Models.SetSecretResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        secretName,\n        value,\n        options\n      },\n      setSecretOperationSpec,\n      callback) as Promise<Models.SetSecretResponse>;\n  }\n\n  /**\n   * The DELETE operation applies to any secret stored in Azure Key Vault. DELETE cannot be applied\n   * to an individual version of a secret. This operation requires the secrets/delete permission.\n   * @summary Deletes a secret from a specified key vault.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.DeleteSecretResponse>\n   */\n  deleteSecret(vaultBaseUrl: string, secretName: string, options?: coreHttp.RequestOptionsBase): Promise<Models.DeleteSecretResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param callback The callback\n   */\n  deleteSecret(vaultBaseUrl: string, secretName: string, callback: coreHttp.ServiceCallback<Models.DeletedSecretBundle>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  deleteSecret(vaultBaseUrl: string, secretName: string, options: coreHttp.RequestOptionsBase, callback: coreHttp.ServiceCallback<Models.DeletedSecretBundle>): void;\n  deleteSecret(vaultBaseUrl: string, secretName: string, options?: coreHttp.RequestOptionsBase | coreHttp.ServiceCallback<Models.DeletedSecretBundle>, callback?: coreHttp.ServiceCallback<Models.DeletedSecretBundle>): Promise<Models.DeleteSecretResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        secretName,\n        options\n      },\n      deleteSecretOperationSpec,\n      callback) as Promise<Models.DeleteSecretResponse>;\n  }\n\n  /**\n   * The UPDATE operation changes specified attributes of an existing stored secret. Attributes that\n   * are not specified in the request are left unchanged. The value of a secret itself cannot be\n   * changed. This operation requires the secrets/set permission.\n   * @summary Updates the attributes associated with a specified secret in a given key vault.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param secretVersion The version of the secret.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.UpdateSecretResponse>\n   */\n  updateSecret(vaultBaseUrl: string, secretName: string, secretVersion: string, options?: Models.KeyVaultClientUpdateSecretOptionalParams): Promise<Models.UpdateSecretResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param secretVersion The version of the secret.\n   * @param callback The callback\n   */\n  updateSecret(vaultBaseUrl: string, secretName: string, secretVersion: string, callback: coreHttp.ServiceCallback<Models.SecretBundle>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param secretVersion The version of the secret.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  updateSecret(vaultBaseUrl: string, secretName: string, secretVersion: string, options: Models.KeyVaultClientUpdateSecretOptionalParams, callback: coreHttp.ServiceCallback<Models.SecretBundle>): void;\n  updateSecret(vaultBaseUrl: string, secretName: string, secretVersion: string, options?: Models.KeyVaultClientUpdateSecretOptionalParams | coreHttp.ServiceCallback<Models.SecretBundle>, callback?: coreHttp.ServiceCallback<Models.SecretBundle>): Promise<Models.UpdateSecretResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        secretName,\n        secretVersion,\n        options\n      },\n      updateSecretOperationSpec,\n      callback) as Promise<Models.UpdateSecretResponse>;\n  }\n\n  /**\n   * The GET operation is applicable to any secret stored in Azure Key Vault. This operation requires\n   * the secrets/get permission.\n   * @summary Get a specified secret from a given key vault.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param secretVersion The version of the secret. This URI fragment is optional. If not specified,\n   * the latest version of the secret is returned.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.GetSecretResponse>\n   */\n  getSecret(vaultBaseUrl: string, secretName: string, secretVersion: string, options?: coreHttp.RequestOptionsBase): Promise<Models.GetSecretResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param secretVersion The version of the secret. This URI fragment is optional. If not specified,\n   * the latest version of the secret is returned.\n   * @param callback The callback\n   */\n  getSecret(vaultBaseUrl: string, secretName: string, secretVersion: string, callback: coreHttp.ServiceCallback<Models.SecretBundle>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param secretVersion The version of the secret. This URI fragment is optional. If not specified,\n   * the latest version of the secret is returned.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  getSecret(vaultBaseUrl: string, secretName: string, secretVersion: string, options: coreHttp.RequestOptionsBase, callback: coreHttp.ServiceCallback<Models.SecretBundle>): void;\n  getSecret(vaultBaseUrl: string, secretName: string, secretVersion: string, options?: coreHttp.RequestOptionsBase | coreHttp.ServiceCallback<Models.SecretBundle>, callback?: coreHttp.ServiceCallback<Models.SecretBundle>): Promise<Models.GetSecretResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        secretName,\n        secretVersion,\n        options\n      },\n      getSecretOperationSpec,\n      callback) as Promise<Models.GetSecretResponse>;\n  }\n\n  /**\n   * The Get Secrets operation is applicable to the entire vault. However, only the base secret\n   * identifier and its attributes are provided in the response. Individual secret versions are not\n   * listed in the response. This operation requires the secrets/list permission.\n   * @summary List secrets in a specified key vault.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.GetSecretsResponse>\n   */\n  getSecrets(vaultBaseUrl: string, options?: Models.KeyVaultClientGetSecretsOptionalParams): Promise<Models.GetSecretsResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param callback The callback\n   */\n  getSecrets(vaultBaseUrl: string, callback: coreHttp.ServiceCallback<Models.SecretListResult>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  getSecrets(vaultBaseUrl: string, options: Models.KeyVaultClientGetSecretsOptionalParams, callback: coreHttp.ServiceCallback<Models.SecretListResult>): void;\n  getSecrets(vaultBaseUrl: string, options?: Models.KeyVaultClientGetSecretsOptionalParams | coreHttp.ServiceCallback<Models.SecretListResult>, callback?: coreHttp.ServiceCallback<Models.SecretListResult>): Promise<Models.GetSecretsResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        options\n      },\n      getSecretsOperationSpec,\n      callback) as Promise<Models.GetSecretsResponse>;\n  }\n\n  /**\n   * The full secret identifier and attributes are provided in the response. No values are returned\n   * for the secrets. This operations requires the secrets/list permission.\n   * @summary List all versions of the specified secret.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.GetSecretVersionsResponse>\n   */\n  getSecretVersions(vaultBaseUrl: string, secretName: string, options?: Models.KeyVaultClientGetSecretVersionsOptionalParams): Promise<Models.GetSecretVersionsResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param callback The callback\n   */\n  getSecretVersions(vaultBaseUrl: string, secretName: string, callback: coreHttp.ServiceCallback<Models.SecretListResult>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  getSecretVersions(vaultBaseUrl: string, secretName: string, options: Models.KeyVaultClientGetSecretVersionsOptionalParams, callback: coreHttp.ServiceCallback<Models.SecretListResult>): void;\n  getSecretVersions(vaultBaseUrl: string, secretName: string, options?: Models.KeyVaultClientGetSecretVersionsOptionalParams | coreHttp.ServiceCallback<Models.SecretListResult>, callback?: coreHttp.ServiceCallback<Models.SecretListResult>): Promise<Models.GetSecretVersionsResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        secretName,\n        options\n      },\n      getSecretVersionsOperationSpec,\n      callback) as Promise<Models.GetSecretVersionsResponse>;\n  }\n\n  /**\n   * The Get Deleted Secrets operation returns the secrets that have been deleted for a vault enabled\n   * for soft-delete. This operation requires the secrets/list permission.\n   * @summary Lists deleted secrets for the specified vault.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.GetDeletedSecretsResponse>\n   */\n  getDeletedSecrets(vaultBaseUrl: string, options?: Models.KeyVaultClientGetDeletedSecretsOptionalParams): Promise<Models.GetDeletedSecretsResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param callback The callback\n   */\n  getDeletedSecrets(vaultBaseUrl: string, callback: coreHttp.ServiceCallback<Models.DeletedSecretListResult>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  getDeletedSecrets(vaultBaseUrl: string, options: Models.KeyVaultClientGetDeletedSecretsOptionalParams, callback: coreHttp.ServiceCallback<Models.DeletedSecretListResult>): void;\n  getDeletedSecrets(vaultBaseUrl: string, options?: Models.KeyVaultClientGetDeletedSecretsOptionalParams | coreHttp.ServiceCallback<Models.DeletedSecretListResult>, callback?: coreHttp.ServiceCallback<Models.DeletedSecretListResult>): Promise<Models.GetDeletedSecretsResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        options\n      },\n      getDeletedSecretsOperationSpec,\n      callback) as Promise<Models.GetDeletedSecretsResponse>;\n  }\n\n  /**\n   * The Get Deleted Secret operation returns the specified deleted secret along with its attributes.\n   * This operation requires the secrets/get permission.\n   * @summary Gets the specified deleted secret.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.GetDeletedSecretResponse>\n   */\n  getDeletedSecret(vaultBaseUrl: string, secretName: string, options?: coreHttp.RequestOptionsBase): Promise<Models.GetDeletedSecretResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param callback The callback\n   */\n  getDeletedSecret(vaultBaseUrl: string, secretName: string, callback: coreHttp.ServiceCallback<Models.DeletedSecretBundle>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  getDeletedSecret(vaultBaseUrl: string, secretName: string, options: coreHttp.RequestOptionsBase, callback: coreHttp.ServiceCallback<Models.DeletedSecretBundle>): void;\n  getDeletedSecret(vaultBaseUrl: string, secretName: string, options?: coreHttp.RequestOptionsBase | coreHttp.ServiceCallback<Models.DeletedSecretBundle>, callback?: coreHttp.ServiceCallback<Models.DeletedSecretBundle>): Promise<Models.GetDeletedSecretResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        secretName,\n        options\n      },\n      getDeletedSecretOperationSpec,\n      callback) as Promise<Models.GetDeletedSecretResponse>;\n  }\n\n  /**\n   * The purge deleted secret operation removes the secret permanently, without the possibility of\n   * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation\n   * requires the secrets/purge permission.\n   * @summary Permanently deletes the specified secret.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param [options] The optional parameters\n   * @returns Promise<coreHttp.RestResponse>\n   */\n  purgeDeletedSecret(vaultBaseUrl: string, secretName: string, options?: coreHttp.RequestOptionsBase): Promise<coreHttp.RestResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param callback The callback\n   */\n  purgeDeletedSecret(vaultBaseUrl: string, secretName: string, callback: coreHttp.ServiceCallback<void>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  purgeDeletedSecret(vaultBaseUrl: string, secretName: string, options: coreHttp.RequestOptionsBase, callback: coreHttp.ServiceCallback<void>): void;\n  purgeDeletedSecret(vaultBaseUrl: string, secretName: string, options?: coreHttp.RequestOptionsBase | coreHttp.ServiceCallback<void>, callback?: coreHttp.ServiceCallback<void>): Promise<coreHttp.RestResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        secretName,\n        options\n      },\n      purgeDeletedSecretOperationSpec,\n      callback);\n  }\n\n  /**\n   * Recovers the deleted secret in the specified vault. This operation can only be performed on a\n   * soft-delete enabled vault. This operation requires the secrets/recover permission.\n   * @summary Recovers the deleted secret to the latest version.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the deleted secret.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.RecoverDeletedSecretResponse>\n   */\n  recoverDeletedSecret(vaultBaseUrl: string, secretName: string, options?: coreHttp.RequestOptionsBase): Promise<Models.RecoverDeletedSecretResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the deleted secret.\n   * @param callback The callback\n   */\n  recoverDeletedSecret(vaultBaseUrl: string, secretName: string, callback: coreHttp.ServiceCallback<Models.SecretBundle>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the deleted secret.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  recoverDeletedSecret(vaultBaseUrl: string, secretName: string, options: coreHttp.RequestOptionsBase, callback: coreHttp.ServiceCallback<Models.SecretBundle>): void;\n  recoverDeletedSecret(vaultBaseUrl: string, secretName: string, options?: coreHttp.RequestOptionsBase | coreHttp.ServiceCallback<Models.SecretBundle>, callback?: coreHttp.ServiceCallback<Models.SecretBundle>): Promise<Models.RecoverDeletedSecretResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        secretName,\n        options\n      },\n      recoverDeletedSecretOperationSpec,\n      callback) as Promise<Models.RecoverDeletedSecretResponse>;\n  }\n\n  /**\n   * Requests that a backup of the specified secret be downloaded to the client. All versions of the\n   * secret will be downloaded. This operation requires the secrets/backup permission.\n   * @summary Backs up the specified secret.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.BackupSecretResponse>\n   */\n  backupSecret(vaultBaseUrl: string, secretName: string, options?: coreHttp.RequestOptionsBase): Promise<Models.BackupSecretResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param callback The callback\n   */\n  backupSecret(vaultBaseUrl: string, secretName: string, callback: coreHttp.ServiceCallback<Models.BackupSecretResult>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretName The name of the secret.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  backupSecret(vaultBaseUrl: string, secretName: string, options: coreHttp.RequestOptionsBase, callback: coreHttp.ServiceCallback<Models.BackupSecretResult>): void;\n  backupSecret(vaultBaseUrl: string, secretName: string, options?: coreHttp.RequestOptionsBase | coreHttp.ServiceCallback<Models.BackupSecretResult>, callback?: coreHttp.ServiceCallback<Models.BackupSecretResult>): Promise<Models.BackupSecretResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        secretName,\n        options\n      },\n      backupSecretOperationSpec,\n      callback) as Promise<Models.BackupSecretResponse>;\n  }\n\n  /**\n   * Restores a backed up secret, and all its versions, to a vault. This operation requires the\n   * secrets/restore permission.\n   * @summary Restores a backed up secret to a vault.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretBundleBackup The backup blob associated with a secret bundle.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.RestoreSecretResponse>\n   */\n  restoreSecret(vaultBaseUrl: string, secretBundleBackup: Uint8Array, options?: coreHttp.RequestOptionsBase): Promise<Models.RestoreSecretResponse>;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretBundleBackup The backup blob associated with a secret bundle.\n   * @param callback The callback\n   */\n  restoreSecret(vaultBaseUrl: string, secretBundleBackup: Uint8Array, callback: coreHttp.ServiceCallback<Models.SecretBundle>): void;\n  /**\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param secretBundleBackup The backup blob associated with a secret bundle.\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  restoreSecret(vaultBaseUrl: string, secretBundleBackup: Uint8Array, options: coreHttp.RequestOptionsBase, callback: coreHttp.ServiceCallback<Models.SecretBundle>): void;\n  restoreSecret(vaultBaseUrl: string, secretBundleBackup: Uint8Array, options?: coreHttp.RequestOptionsBase | coreHttp.ServiceCallback<Models.SecretBundle>, callback?: coreHttp.ServiceCallback<Models.SecretBundle>): Promise<Models.RestoreSecretResponse> {\n    return this.sendOperationRequest(\n      {\n        vaultBaseUrl,\n        secretBundleBackup,\n        options\n      },\n      restoreSecretOperationSpec,\n      callback) as Promise<Models.RestoreSecretResponse>;\n  }\n}\n\n// Operation Specifications\nconst serializer = new coreHttp.Serializer(Mappers);\nconst setSecretOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"PUT\",\n  path: \"secrets/{secret-name}\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.secretName0\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  requestBody: {\n    parameterPath: {\n      value: \"value\",\n      tags: [\n        \"options\",\n        \"tags\"\n      ],\n      contentType: [\n        \"options\",\n        \"contentType\"\n      ],\n      secretAttributes: [\n        \"options\",\n        \"secretAttributes\"\n      ]\n    },\n    mapper: {\n      ...Mappers.SecretSetParameters,\n      required: true\n    }\n  },\n  responses: {\n    200: {\n      bodyMapper: Mappers.SecretBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst deleteSecretOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"DELETE\",\n  path: \"secrets/{secret-name}\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.secretName1\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeletedSecretBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst updateSecretOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"PATCH\",\n  path: \"secrets/{secret-name}/{secret-version}\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.secretName1,\n    Parameters.secretVersion\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  requestBody: {\n    parameterPath: {\n      contentType: [\n        \"options\",\n        \"contentType\"\n      ],\n      secretAttributes: [\n        \"options\",\n        \"secretAttributes\"\n      ],\n      tags: [\n        \"options\",\n        \"tags\"\n      ]\n    },\n    mapper: {\n      ...Mappers.SecretUpdateParameters,\n      required: true\n    }\n  },\n  responses: {\n    200: {\n      bodyMapper: Mappers.SecretBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst getSecretOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"GET\",\n  path: \"secrets/{secret-name}/{secret-version}\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.secretName1,\n    Parameters.secretVersion\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  responses: {\n    200: {\n      bodyMapper: Mappers.SecretBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst getSecretsOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"GET\",\n  path: \"secrets\",\n  urlParameters: [\n    Parameters.vaultBaseUrl\n  ],\n  queryParameters: [\n    Parameters.maxresults,\n    Parameters.apiVersion\n  ],\n  responses: {\n    200: {\n      bodyMapper: Mappers.SecretListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst getSecretVersionsOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"GET\",\n  path: \"secrets/{secret-name}/versions\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.secretName1\n  ],\n  queryParameters: [\n    Parameters.maxresults,\n    Parameters.apiVersion\n  ],\n  responses: {\n    200: {\n      bodyMapper: Mappers.SecretListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst getDeletedSecretsOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"GET\",\n  path: \"deletedsecrets\",\n  urlParameters: [\n    Parameters.vaultBaseUrl\n  ],\n  queryParameters: [\n    Parameters.maxresults,\n    Parameters.apiVersion\n  ],\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeletedSecretListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst getDeletedSecretOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"GET\",\n  path: \"deletedsecrets/{secret-name}\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.secretName1\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeletedSecretBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst purgeDeletedSecretOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"DELETE\",\n  path: \"deletedsecrets/{secret-name}\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.secretName1\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  responses: {\n    204: {},\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst recoverDeletedSecretOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"POST\",\n  path: \"deletedsecrets/{secret-name}/recover\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.secretName1\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  responses: {\n    200: {\n      bodyMapper: Mappers.SecretBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst backupSecretOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"POST\",\n  path: \"secrets/{secret-name}/backup\",\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.secretName1\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  responses: {\n    200: {\n      bodyMapper: Mappers.BackupSecretResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nconst restoreSecretOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"POST\",\n  path: \"secrets/restore\",\n  urlParameters: [\n    Parameters.vaultBaseUrl\n  ],\n  queryParameters: [\n    Parameters.apiVersion\n  ],\n  requestBody: {\n    parameterPath: {\n      secretBundleBackup: \"secretBundleBackup\"\n    },\n    mapper: {\n      ...Mappers.SecretRestoreParameters,\n      required: true\n    }\n  },\n  responses: {\n    200: {\n      bodyMapper: Mappers.SecretBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  serializer\n};\n\nexport {\n  KeyVaultClient,\n  KeyVaultClientContext,\n  Models as KeyVaultModels,\n  Mappers as KeyVaultMappers\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\nexport const SDK_VERSION: string = \"4.1.0\";\n\nexport const RetryConstants = {\n  MIN_RETRY_INTERVAL_MS: 3000\n};\n\nexport const HeaderConstants = {\n  USER_AGENT: \"User-Agent\",\n  X_MS_CLIENT_REQUEST_ID: \"x-ms-client-request-id\"\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\nimport { TokenCredential } from \"@azure/core-http\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyOptions,\n  RequestPolicyFactory,\n} from \"@azure/core-http\";\nimport { Constants } from \"@azure/core-http\";\nimport { HttpOperationResponse } from \"@azure/core-http\";\nimport { WebResource } from \"@azure/core-http\";\nimport { AccessTokenCache, ExpiringAccessTokenCache } from \"@azure/core-http\";\n\ntype ValidParsedWWWAuthenticateProperties =\n  // \"authorization_uri\" was used in the track 1 version of KeyVault.\n  // This is not a relevant property anymore, since the service is consistently answering with \"authorization\".\n  // | \"authorization_uri\"\n  | \"authorization\"\n  // Even though the service is moving to \"scope\", both \"resource\" and \"scope\" should be supported.\n  | \"resource\"\n  | \"scope\";\n\ntype ParsedWWWAuthenticate = {\n  [Key in ValidParsedWWWAuthenticateProperties]?: string;\n};\n\n/**\n * Representation of the Authentication Challenge\n */\nexport class AuthenticationChallenge {\n  constructor(public authorization: string, public scope: string) {}\n\n  /**\n   * Checks that this AuthenticationChallenge is equal to another one given.\n   * Only compares the scope.\n   * This is exactly what C# is doing, as we can see here:\n   * https://github.com/Azure/azure-sdk-for-net/blob/70e54b878ff1d01a45266fb3674a396b4ab9c1d2/sdk/keyvault/Azure.Security.KeyVault.Shared/src/ChallengeBasedAuthenticationPolicy.cs#L143-L147\n   * @param other The other AuthenticationChallenge\n   */\n  public equalTo(other: AuthenticationChallenge | undefined) {\n    return other\n      ? this.scope.toLowerCase() === other.scope.toLowerCase() &&\n          this.authorization.toLowerCase() === other.authorization.toLowerCase()\n      : false;\n  }\n}\n\n/**\n * Helps keep a copy of any previous authentication challenges,\n * so that we can compare on any further request.\n */\nexport class AuthenticationChallengeCache {\n  public challenge?: AuthenticationChallenge;\n\n  public setCachedChallenge(challenge: AuthenticationChallenge) {\n    this.challenge = challenge;\n  }\n}\n\n/**\n * Creates a new ChallengeBasedAuthenticationPolicy factory.\n *\n * @param credential The TokenCredential implementation that can supply the challenge token.\n */\nexport function challengeBasedAuthenticationPolicy(\n  credential: TokenCredential\n): RequestPolicyFactory {\n  const tokenCache: AccessTokenCache = new ExpiringAccessTokenCache();\n  const challengeCache = new AuthenticationChallengeCache();\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new ChallengeBasedAuthenticationPolicy(\n        nextPolicy,\n        options,\n        credential,\n        tokenCache,\n        challengeCache\n      );\n    },\n  };\n}\n\n/**\n * Parses an WWW-Authenticate response.\n * This transforms a string value like:\n * `Bearer authorization=\"some_authorization\", resource=\"https://some.url\"`\n * into an object like:\n * `{ authorization: \"some_authorization\", resource: \"https://some.url\" }`\n * @param wwwAuthenticate string value in the WWW-Authenticate header\n */\nexport function parseWWWAuthenticate(wwwAuthenticate: string): ParsedWWWAuthenticate {\n  // First we split the string by either `, ` or ` `.\n  const parts = wwwAuthenticate.split(/,* +/);\n  // Then we only keep the strings with an equal sign after a word and before a quote.\n  // also splitting these sections by their equal sign\n  const keyValues = parts.reduce<string[][]>(\n    (parts, str) => (str.match(/\\w=\"/) ? [...parts, str.split(\"=\")] : parts),\n    []\n  );\n  // Then we transform these key-value pairs back into an object.\n  const parsed = keyValues.reduce<ParsedWWWAuthenticate>(\n    (result, [key, value]: string[]) => ({\n      ...result,\n      [key]: value.slice(1, -1),\n    }),\n    {}\n  );\n  return parsed;\n}\n\n/**\n *\n * Provides a RequestPolicy that can request a token from a TokenCredential\n * implementation and then apply it to the Authorization header of a request\n * as a Bearer token.\n *\n */\nexport class ChallengeBasedAuthenticationPolicy extends BaseRequestPolicy {\n  private parseWWWAuthenticate: (\n    wwwAuthenticate: string\n  ) => ParsedWWWAuthenticate = parseWWWAuthenticate;\n\n  /**\n   * Creates a new ChallengeBasedAuthenticationPolicy object.\n   *\n   * @param nextPolicy The next RequestPolicy in the request pipeline.\n   * @param options Options for this RequestPolicy.\n   * @param credential The TokenCredential implementation that can supply the bearer token.\n   * @param tokenCache The cache for the most recent AccessToken returned by the TokenCredential.\n   */\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    private credential: TokenCredential,\n    private tokenCache: AccessTokenCache,\n    private challengeCache: AuthenticationChallengeCache\n  ) {\n    super(nextPolicy, options);\n  }\n\n  /**\n   * Gets or updates the token from the token cache into the headers of the received web resource.\n   */\n  private async loadToken(webResource: WebResource): Promise<void> {\n    let accessToken = this.tokenCache.getCachedToken();\n\n    // If there's no cached token in the cache, we try to get a new one.\n    if (accessToken === undefined) {\n      const receivedToken = await this.credential.getToken(this.challengeCache.challenge!.scope);\n      accessToken = receivedToken || undefined;\n      this.tokenCache.setCachedToken(accessToken);\n    }\n\n    if (accessToken) {\n      webResource.headers.set(\n        Constants.HeaderConstants.AUTHORIZATION,\n        `Bearer ${accessToken.token}`\n      );\n    }\n  }\n\n  /**\n   * Parses the given WWW-Authenticate header, generates a new AuthenticationChallenge,\n   * then if the challenge is different from the one cached, resets the token and forces\n   * a re-authentication, otherwise continues with the existing challenge and token.\n   * @param wwwAuthenticate Value of the incoming WWW-Authenticate header.\n   * @param webResource Ongoing HTTP request.\n   */\n  private async regenerateChallenge(\n    wwwAuthenticate: string,\n    webResource: WebResource\n  ): Promise<HttpOperationResponse> {\n    // The challenge based authentication will contain both:\n    // - An authorization URI with a token,\n    // - The resource to which that token is valid against (also called the scope).\n    const parsedWWWAuth = this.parseWWWAuthenticate(wwwAuthenticate);\n    const authorization = parsedWWWAuth.authorization!;\n    const resource = parsedWWWAuth.resource! || parsedWWWAuth.scope!;\n\n    if (!(authorization && resource)) {\n      return this._nextPolicy.sendRequest(webResource);\n    }\n\n    const challenge = new AuthenticationChallenge(authorization, resource + \"/.default\");\n\n    // Either if there's no cached challenge at this point (could have happen in parallel),\n    // or if the cached challenge has a different scope,\n    // we store the just received challenge and reset the cached token, to force a re-authentication.\n    if (!this.challengeCache.challenge?.equalTo(challenge)) {\n      this.challengeCache.setCachedChallenge(challenge);\n      this.tokenCache.setCachedToken(undefined);\n    }\n\n    await this.loadToken(webResource);\n    return this._nextPolicy.sendRequest(webResource);\n  }\n\n  /**\n   * Applies the Bearer token to the request through the Authorization header.\n   * @param webResource Ongoing HTTP request.\n   */\n  public async sendRequest(webResource: WebResource): Promise<HttpOperationResponse> {\n    // Ensure that we're about to use a secure connection.\n    if (!webResource.url.startsWith(\"https:\")) {\n      throw new Error(\"The resource address for authorization must use the 'https' protocol.\");\n    }\n\n    // The next request will happen differently whether we have a challenge or not.\n    let response: HttpOperationResponse;\n\n    if (this.challengeCache.challenge == undefined) {\n      // If there's no challenge in cache, a blank body will start the challenge.\n      const originalBody = webResource.body;\n      webResource.body = \"\";\n      response = await this._nextPolicy.sendRequest(webResource);\n      webResource.body = originalBody;\n    } else {\n      // If we did have a challenge in memory,\n      // we attempt to load the token from the cache into the request before we try to send the request.\n      await this.loadToken(webResource);\n      response = await this._nextPolicy.sendRequest(webResource);\n    }\n\n    // If we don't receive a response with a 401 status code,\n    // then we can assume this response has nothing to do with the challenge authentication process.\n    if (response.status !== 401) {\n      return response;\n    }\n\n    // If the response status is 401, we only re-authenticate if the WWW-Authenticate header is present.\n    const wwwAuthenticate = response.headers.get(\"WWW-Authenticate\");\n    if (!wwwAuthenticate) {\n      return response;\n    }\n\n    // We re-generate the challenge and see if we have to re-authenticate.\n    return await this.regenerateChallenge(wwwAuthenticate, webResource);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { PollOperationState, PollOperation } from \"@azure/core-lro\";\nimport { RequestOptionsBase } from \"@azure/core-http\";\nimport { DeletedSecret, SecretClientInterface } from \"../../secretsModels\";\n\n/**\n * An interface representing the state of a delete secret's poll operation\n */\nexport interface DeleteSecretPollOperationState extends PollOperationState<DeletedSecret> {\n  /**\n   * The name of the secret.\n   */\n  name: string;\n  /**\n   * Options for the core-http requests.\n   */\n  requestOptions?: RequestOptionsBase;\n  /**\n   * An interface representing a SecretClient. For internal use.\n   */\n  client: SecretClientInterface;\n}\n\n/**\n * An interface representing a delete secret's poll operation\n */\nexport interface DeleteSecretPollOperation\n  extends PollOperation<DeleteSecretPollOperationState, DeletedSecret> {}\n\n/**\n * @summary Reaches to the service and updates the delete secret's poll operation.\n * @param [options] The optional parameters, which are an abortSignal from @azure/abort-controller and a function that triggers the poller's onProgress function.\n */\nasync function update(\n  this: DeleteSecretPollOperation,\n  options: {\n    abortSignal?: AbortSignalLike;\n    fireProgress?: (state: DeleteSecretPollOperationState) => void;\n  } = {}\n): Promise<DeleteSecretPollOperation> {\n  const state = this.state;\n  const { name, client } = state;\n\n  const requestOptions = state.requestOptions || {};\n  if (options.abortSignal) {\n    requestOptions.abortSignal = options.abortSignal;\n  }\n\n  if (!state.isStarted) {\n    const deletedSecret = await client.deleteSecret(name, requestOptions);\n    state.isStarted = true;\n    state.result = deletedSecret;\n    if (!deletedSecret.properties.recoveryId) {\n      state.isCompleted = true;\n    }\n  }\n\n  if (!state.isCompleted) {\n    try {\n      state.result = await client.getDeletedSecret(name, { requestOptions });\n      state.isCompleted = true;\n    } catch (error) {\n      if (error.statusCode === 403) {\n        // At this point, the resource exists but the user doesn't have access to it.\n        state.isCompleted = true;\n      } else if (error.statusCode !== 404) {\n        state.error = error;\n        state.isCompleted = true;\n      }\n    }\n  }\n\n  return makeDeleteSecretPollOperation(state);\n}\n\n/**\n * @summary Reaches to the service and cancels the secret's operation, also updating the secret's poll operation\n * @param [options] The optional parameters, which is only an abortSignal from @azure/abort-controller\n */\nasync function cancel(this: DeleteSecretPollOperation): Promise<DeleteSecretPollOperation> {\n  throw new Error(\"Canceling the deletion of a secret is not supported.\");\n}\n\n/**\n * @summary Serializes the create secret's poll operation\n */\nfunction toString(this: DeleteSecretPollOperation): string {\n  return JSON.stringify({\n    state: this.state\n  });\n}\n\n/**\n * @summary Builds a create secret's poll operation\n * @param [state] A poll operation's state, in case the new one is intended to follow up where the previous one was left.\n */\nexport function makeDeleteSecretPollOperation(\n  state: DeleteSecretPollOperationState\n): DeleteSecretPollOperation {\n  return {\n    state: {\n      ...state\n    },\n    update,\n    cancel,\n    toString\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { delay, RequestOptionsBase } from \"@azure/core-http\";\nimport { Poller } from \"@azure/core-lro\";\nimport { DeleteSecretPollOperationState, makeDeleteSecretPollOperation } from \"./operation\";\nimport { DeletedSecret, SecretClientInterface } from \"../../secretsModels\";\n\nexport interface DeleteSecretPollerOptions {\n  client: SecretClientInterface;\n  name: string;\n  requestOptions?: RequestOptionsBase;\n  intervalInMs?: number;\n  resumeFrom?: string;\n}\n\n/**\n * Class that deletes a poller that waits until a secret finishes being deleted\n */\nexport class DeleteSecretPoller extends Poller<DeleteSecretPollOperationState, DeletedSecret> {\n  /**\n   * Defines how much time the poller is going to wait before making a new request to the service.\n   * @memberof DeleteSecretPoller\n   */\n  public intervalInMs: number;\n\n  constructor(options: DeleteSecretPollerOptions) {\n    const { client, name, requestOptions, intervalInMs = 2000, resumeFrom } = options;\n\n    let state: DeleteSecretPollOperationState | undefined;\n\n    if (resumeFrom) {\n      state = JSON.parse(resumeFrom).state;\n    }\n\n    const operation = makeDeleteSecretPollOperation({\n      ...state,\n      name,\n      requestOptions,\n      client\n    });\n\n    super(operation);\n\n    this.intervalInMs = intervalInMs;\n  }\n\n  /**\n   * The method used by the poller to wait before attempting to update its operation.\n   * @memberof DeleteSecretPoller\n   */\n  async delay(): Promise<void> {\n    return delay(this.intervalInMs);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { PollOperationState, PollOperation } from \"@azure/core-lro\";\nimport { RequestOptionsBase } from \"@azure/core-http\";\nimport { SecretProperties, SecretClientInterface } from \"../../secretsModels\";\n\n/**\n * An interface representing the state of a delete secret's poll operation\n */\nexport interface RecoverDeletedSecretPollOperationState\n  extends PollOperationState<SecretProperties> {\n  /**\n   * The name of the secret.\n   */\n  name: string;\n  /**\n   * Options for the core-http requests.\n   */\n  requestOptions?: RequestOptionsBase;\n  /**\n   * An interface representing a SecretClient. For internal use.\n   */\n  client: SecretClientInterface;\n}\n\n/**\n * An interface representing a delete secret's poll operation\n */\nexport interface RecoverDeletedSecretPollOperation\n  extends PollOperation<RecoverDeletedSecretPollOperationState, SecretProperties> {}\n\n/**\n * @summary Reaches to the service and updates the delete secret's poll operation.\n * @param [options] The optional parameters, which are an abortSignal from @azure/abort-controller and a function that triggers the poller's onProgress function.\n */\nasync function update(\n  this: RecoverDeletedSecretPollOperation,\n  options: {\n    abortSignal?: AbortSignalLike;\n    fireProgress?: (state: RecoverDeletedSecretPollOperationState) => void;\n  } = {}\n): Promise<RecoverDeletedSecretPollOperation> {\n  const state = this.state;\n  const { name, client } = state;\n\n  const requestOptions = state.requestOptions || {};\n  if (options.abortSignal) {\n    requestOptions.abortSignal = options.abortSignal;\n  }\n\n  if (!state.isStarted) {\n    try {\n      state.result = (await client.getSecret(name, { requestOptions })).properties;\n      state.isCompleted = true;\n    } catch {\n      // Nothing to do here.\n    }\n    if (!state.isCompleted) {\n      state.result = await client.recoverDeletedSecret(name, { requestOptions });\n      state.isStarted = true;\n    }\n  }\n\n  if (!state.isCompleted) {\n    try {\n      state.result = (await client.getSecret(name, { requestOptions })).properties;\n      state.isCompleted = true;\n    } catch (error) {\n      if (error.statusCode === 403) {\n        // At this point, the resource exists but the user doesn't have access to it.\n        state.isCompleted = true;\n      } else if (error.statusCode !== 404) {\n        state.error = error;\n        state.isCompleted = true;\n      }\n    }\n  }\n\n  return makeRecoverDeletedSecretPollOperation(state);\n}\n\n/**\n * @summary Reaches to the service and cancels the secret's operation, also updating the secret's poll operation\n * @param [options] The optional parameters, which is only an abortSignal from @azure/abort-controller\n */\nasync function cancel(\n  this: RecoverDeletedSecretPollOperation\n): Promise<RecoverDeletedSecretPollOperation> {\n  throw new Error(\"Canceling the deletion of a secret is not supported.\");\n}\n\n/**\n * @summary Serializes the create secret's poll operation\n */\nfunction toString(this: RecoverDeletedSecretPollOperation): string {\n  return JSON.stringify({\n    state: this.state\n  });\n}\n\n/**\n * @summary Builds a create secret's poll operation\n * @param [state] A poll operation's state, in case the new one is intended to follow up where the previous one was left.\n */\nexport function makeRecoverDeletedSecretPollOperation(\n  state: RecoverDeletedSecretPollOperationState\n): RecoverDeletedSecretPollOperation {\n  return {\n    state: {\n      ...state\n    },\n    update,\n    cancel,\n    toString\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { delay, RequestOptionsBase } from \"@azure/core-http\";\nimport { Poller } from \"@azure/core-lro\";\nimport {\n  RecoverDeletedSecretPollOperationState,\n  makeRecoverDeletedSecretPollOperation\n} from \"./operation\";\nimport { SecretProperties, SecretClientInterface } from \"../../secretsModels\";\n\nexport interface RecoverDeletedSecretPollerOptions {\n  client: SecretClientInterface;\n  name: string;\n  requestOptions?: RequestOptionsBase;\n  intervalInMs?: number;\n  resumeFrom?: string;\n}\n\n/**\n * Class that deletes a poller that waits until a secret finishes being deleted\n */\nexport class RecoverDeletedSecretPoller extends Poller<\n  RecoverDeletedSecretPollOperationState,\n  SecretProperties\n> {\n  /**\n   * Defines how much time the poller is going to wait before making a new request to the service.\n   * @memberof RecoverDeletedSecretPoller\n   */\n  public intervalInMs: number;\n\n  constructor(options: RecoverDeletedSecretPollerOptions) {\n    const { client, name, requestOptions, intervalInMs = 2000, resumeFrom } = options;\n\n    let state: RecoverDeletedSecretPollOperationState | undefined;\n\n    if (resumeFrom) {\n      state = JSON.parse(resumeFrom).state;\n    }\n\n    const operation = makeRecoverDeletedSecretPollOperation({\n      ...state,\n      name,\n      requestOptions,\n      client\n    });\n\n    super(operation);\n\n    this.intervalInMs = intervalInMs;\n  }\n\n  /**\n   * The method used by the poller to wait before attempting to update its operation.\n   * @memberof RecoverDeletedSecretPoller\n   */\n  async delay(): Promise<void> {\n    return delay(this.intervalInMs);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as coreHttp from \"@azure/core-http\";\nimport { DeletionRecoveryLevel } from \"./generated/models\";\n\n/**\n * @internal\n * @ignore\n * An interface representing the SecretClient. For internal use.\n */\nexport interface SecretClientInterface {\n  /**\n   * Recovers the deleted secret in the specified vault.\n   */\n  recoverDeletedSecret(\n    secretName: string,\n    options?: RecoverDeletedSecretOptions\n  ): Promise<SecretProperties>;\n  /**\n   * The getSecret method is applicable to any secret stored in Azure Key Vault. This operation requires\n   * the secrets/get permission.\n   */\n  getSecret(secretName: string, options?: GetSecretOptions): Promise<KeyVaultSecret>;\n  /**\n   * Deletes a secret stored in Azure Key Vault.\n   */\n  deleteSecret(secretName: string, options?: coreHttp.OperationOptions): Promise<DeletedSecret>;\n  /**\n   * The getDeletedSecret method returns the specified deleted secret along with its properties.\n   * This operation requires the secrets/get permission.\n   */\n  getDeletedSecret(secretName: string, options?: DeleteSecretOptions): Promise<DeletedSecret>;\n}\n\n/**\n * The latest supported KeyVault service API version\n */\nexport const LATEST_API_VERSION = \"7.1\";\n\n/**\n * The optional parameters accepted by the KeyVault's KeyClient\n */\nexport interface SecretClientOptions extends coreHttp.PipelineOptions {\n  /**\n   * The accepted versions of the KeyVault's service API.\n   */\n  serviceVersion?: \"7.0\" | \"7.1\";\n}\n\n/**\n * An interface representing a KeyVault Secret, with its name, value and {@link SecretProperties}.\n */\nexport interface KeyVaultSecret {\n  /**\n   * The properties of the secret.\n   */\n  properties: SecretProperties;\n  /**\n   * The value of the secret.\n   */\n  value?: string;\n  /**\n   * The name of the secret.\n   */\n  name: string;\n}\n\n/**\n * An interface representing the properties of a {@link KeyVaultSecret}.\n */\nexport interface SecretProperties {\n  /**\n   * The base URL to the vault.\n   */\n  vaultUrl: string;\n  /**\n   * The version of the secret. May be undefined.\n   */\n  version?: string;\n  /**\n   * The name of the secret.\n   */\n  name: string;\n  /**\n   * The secret id.\n   */\n  id?: string;\n  /**\n   * The content type of the secret.\n   */\n  contentType?: string;\n  /**\n   * Determines whether the object is enabled.\n   */\n  enabled?: boolean;\n  /**\n   * Not before date in UTC.\n   */\n  readonly notBefore?: Date;\n  /**\n   * Expiry date in UTC.\n   */\n  readonly expiresOn?: Date;\n  /**\n   * Application specific\n   * metadata in the form of key-value pairs.\n   */\n  tags?: { [propertyName: string]: string };\n  /**\n   * If this is a secret backing a KV certificate, then\n   * this field specifies the corresponding key backing the KV certificate.\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  readonly keyId?: URL;\n  /**\n   * True if the secret's lifetime is managed by\n   * key vault. If this is a secret backing a certificate, then managed will be\n   * true.\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  readonly managed?: boolean;\n  /**\n   * Creation time in UTC.\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  readonly createdOn?: Date;\n  /**\n   * Last updated time in UTC.\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  readonly updatedOn?: Date;\n  /**\n   * Reflects the deletion\n   * recovery level currently in effect for keys in the current vault. If it\n   * contains 'Purgeable' the key can be permanently deleted by a privileged\n   * user; otherwise, only the system can purge the key, at the end of the\n   * retention interval. Possible values include: 'Purgeable',\n   * 'Recoverable+Purgeable', 'Recoverable',\n   * 'Recoverable+ProtectedSubscription'\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  readonly recoveryLevel?: DeletionRecoveryLevel;\n  /**\n   * The retention dates of the softDelete data.\n   * The value should be >=7 and <=90 when softDelete enabled.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  recoverableDays?: number;\n}\n\n/**\n * An interface representing a deleted KeyVault Secret.\n */\nexport interface DeletedSecret {\n  /**\n   * The properties of the secret\n   */\n  properties: SecretProperties & {\n    /**\n     * The url of the recovery object, used to\n     * identify and recover the deleted secret.\n     */\n    recoveryId?: string;\n    /**\n     * The time when the secret is scheduled\n     * to be purged, in UTC\n     * **NOTE: This property will not be serialized. It can only be populated by\n     * the server.**\n     */\n    scheduledPurgeDate?: Date;\n    /**\n     * The time when the secret was deleted, in UTC\n     * **NOTE: This property will not be serialized. It can only be populated by\n     * the server.**\n     */\n    deletedOn?: Date;\n  };\n  /**\n   * The secret value.\n   */\n  value?: string;\n  /**\n   * The name of the secret.\n   */\n  name: string;\n}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link beginDeleteSecret} and {@link beginRecoverDeletedKey}.\n */\nexport interface SecretPollerOptions extends coreHttp.OperationOptions {\n  /**\n   * Time between each polling in milliseconds.\n   */\n  intervalInMs?: number;\n  /**\n   * A serialized poller, used to resume an existing operation\n   */\n  resumeFrom?: string;\n}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link beginDeleteSecret}\n */\nexport interface BeginDeleteSecretOptions extends SecretPollerOptions {}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link beginRecoverDeletedSecret}\n */\nexport interface BeginRecoverDeletedSecretOptions extends SecretPollerOptions {}\n\n/**\n * Options for {@link setSecret}.\n */\nexport interface SetSecretOptions extends coreHttp.OperationOptions {\n  /**\n   * Application specific metadata in the form of key-value pairs.\n   */\n  tags?: { [propertyName: string]: string };\n  /**\n   * Type of the secret value such as a password.\n   */\n  contentType?: string;\n  /**\n   * Determines whether the object is enabled.\n   */\n  enabled?: boolean;\n  /**\n   * Not before date in UTC.\n   */\n  readonly notBefore?: Date;\n  /**\n   * Expiry date in UTC.\n   */\n  readonly expiresOn?: Date;\n}\n\n/**\n * Options for {@link updateSecretProperties}.\n */\nexport interface UpdateSecretPropertiesOptions extends coreHttp.OperationOptions {\n  /**\n   * Type of the secret value such as a password.\n   */\n  contentType?: string;\n  /**\n   * Determines whether the object is enabled.\n   */\n  enabled?: boolean;\n  /**\n   * Not before date in UTC.\n   */\n  readonly notBefore?: Date;\n  /**\n   * Expiry date in UTC.\n   */\n  readonly expiresOn?: Date;\n  /**\n   * Application specific metadata in the form of key-value pairs.\n   */\n  tags?: { [propertyName: string]: string };\n}\n\n/**\n * Options for {@link getSecret}.\n */\nexport interface GetSecretOptions extends coreHttp.OperationOptions {\n  /**\n   * The version of the secret to retrieve. If not\n   * specified the latest version of the secret will be retrieved.\n   */\n  version?: string;\n}\n\n/**\n * Options for {@link getDeletedSecret}.\n */\nexport interface GetDeletedSecretOptions extends coreHttp.OperationOptions {}\n\n/**\n * Options for {@link purgeDeletedSecret}.\n */\nexport interface PurgeDeletedSecretOptions extends coreHttp.OperationOptions {}\n\n/**\n * Options for {@link backupSecretOptions}.\n */\nexport interface BackupSecretOptions extends coreHttp.OperationOptions {}\n\n/**\n * Options for {@link restoreSecretBackup}.\n */\nexport interface RestoreSecretBackupOptions extends coreHttp.OperationOptions {}\n\n/**\n * @internal\n * @ignore\n * Options for {@link recoverDeletedSecret}.\n */\nexport interface RecoverDeletedSecretOptions extends coreHttp.OperationOptions {}\n\n/**\n * @internal\n * @ignore\n * Options for {@link deleteSecret}.\n */\nexport interface DeleteSecretOptions extends coreHttp.OperationOptions {}\n\n/**\n * Options for {@link listPropertiesOfSecretVersions}.\n */\nexport interface ListPropertiesOfSecretVersionsOptions extends coreHttp.OperationOptions {}\n\n/**\n * Options for {@link listPropertiesOfSecrets}.\n */\nexport interface ListPropertiesOfSecretsOptions extends coreHttp.OperationOptions {}\n\n/**\n * Options for {@link listDeletedSecrets}.\n */\nexport interface ListDeletedSecretsOptions extends coreHttp.OperationOptions {}\n","import { ParsedKeyVaultEntityIdentifier } from \"./keyVaultBase\";\nimport * as url from \"url\";\n\nexport function parseKeyvaultIdentifier(\n  collection: string,\n  identifier: string | undefined\n): ParsedKeyVaultEntityIdentifier {\n  if (typeof collection != \"string\" || !(collection = collection.trim())) {\n    throw new Error(\"Invalid collection argument\");\n  }\n\n  if (typeof identifier != \"string\" || !(identifier = identifier.trim())) {\n    throw new Error(\"Invalid identifier argument\");\n  }\n\n  var baseUri;\n  try {\n    baseUri = url.parse(identifier, true, true);\n  } catch (e) {\n    throw new Error(`Invalid ${collection} identifier: ${identifier}. Not a valid URI`);\n  }\n\n  // Path is of the form '/collection/name[/version]'\n  var segments = (baseUri.pathname || \"\").split(\"/\");\n  if (segments.length !== 3 && segments.length !== 4) {\n    throw new Error(\n      `Invalid ${collection} identifier: ${identifier}. Bad number of segments: ${segments.length}`\n    );\n  }\n\n  if (collection !== segments[1]) {\n    throw new Error(\n      `Invalid ${collection} identifier: ${identifier}. segment [1] should be \"${collection}\", found \"${segments[1]}\"`\n    );\n  }\n\n  var vaultUrl = `${baseUri.protocol}//${baseUri.host}`;\n  var name = segments[2];\n  var version = segments.length === 4 ? segments[3] : undefined;\n  return {\n    vaultUrl,\n    name,\n    version\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/* eslint @typescript-eslint/member-ordering: 0 */\n/// <reference lib=\"esnext.asynciterable\" />\n\nimport {\n  TokenCredential,\n  isTokenCredential,\n  signingPolicy,\n  RequestOptionsBase,\n  operationOptionsToRequestOptionsBase,\n  PipelineOptions,\n  createPipelineFromOptions\n} from \"@azure/core-http\";\n\nimport { getTracer } from \"@azure/core-tracing\";\nimport { Span } from \"@opentelemetry/api\";\nimport { logger } from \"./log\";\n\nimport \"@azure/core-paging\";\nimport { PageSettings, PagedAsyncIterableIterator } from \"@azure/core-paging\";\nimport { PollerLike, PollOperationState } from \"@azure/core-lro\";\nimport {\n  SecretBundle,\n  DeletedSecretBundle,\n  DeletionRecoveryLevel,\n  KeyVaultClientGetSecretsOptionalParams,\n  SetSecretResponse,\n  DeleteSecretResponse,\n  UpdateSecretResponse,\n  GetSecretResponse,\n  GetDeletedSecretResponse,\n  BackupSecretResponse,\n  RestoreSecretResponse\n} from \"./generated/models\";\nimport { KeyVaultClient } from \"./generated/keyVaultClient\";\nimport { SDK_VERSION } from \"./generated/utils/constants\";\nimport { challengeBasedAuthenticationPolicy } from \"../../keyvault-common/src\";\n\nimport { DeleteSecretPoller } from \"./lro/delete/poller\";\nimport { RecoverDeletedSecretPoller } from \"./lro/recover/poller\";\n\nimport {\n  KeyVaultSecret,\n  DeletedSecret,\n  DeleteSecretOptions,\n  SecretClientInterface,\n  SecretPollerOptions,\n  BeginDeleteSecretOptions,\n  BeginRecoverDeletedSecretOptions,\n  SetSecretOptions,\n  UpdateSecretPropertiesOptions,\n  GetSecretOptions,\n  GetDeletedSecretOptions,\n  PurgeDeletedSecretOptions,\n  BackupSecretOptions,\n  RestoreSecretBackupOptions,\n  RecoverDeletedSecretOptions,\n  ListPropertiesOfSecretVersionsOptions,\n  ListPropertiesOfSecretsOptions,\n  ListDeletedSecretsOptions,\n  SecretProperties,\n  SecretClientOptions,\n  LATEST_API_VERSION\n} from \"./secretsModels\";\nimport { parseKeyvaultIdentifier as parseKeyvaultEntityIdentifier } from \"./generated/utils\";\n\nexport {\n  SecretClientOptions,\n  DeletedSecret,\n  DeletionRecoveryLevel,\n  GetSecretOptions,\n  PipelineOptions,\n  GetDeletedSecretOptions,\n  PurgeDeletedSecretOptions,\n  BackupSecretOptions,\n  RestoreSecretBackupOptions,\n  ListPropertiesOfSecretVersionsOptions,\n  ListPropertiesOfSecretsOptions,\n  ListDeletedSecretsOptions,\n  PagedAsyncIterableIterator,\n  PageSettings,\n  PollerLike,\n  PollOperationState,\n  KeyVaultSecret,\n  SecretProperties,\n  SecretPollerOptions,\n  BeginDeleteSecretOptions,\n  BeginRecoverDeletedSecretOptions,\n  SetSecretOptions,\n  UpdateSecretPropertiesOptions,\n  logger\n};\n\n/**\n * The SecretClient provides methods to manage {@link KeyVaultSecret} in\n * the Azure Key Vault. The client supports creating, retrieving, updating,\n * deleting, purging, backing up, restoring and listing KeyVaultSecrets. The\n * client also supports listing {@link DeletedSecret} for a soft-delete enabled Azure\n * Key Vault.\n */\nexport class SecretClient {\n  /**\n   * The base URL to the vault\n   */\n  public readonly vaultUrl: string;\n\n  /**\n   * @internal\n   * @ignore\n   * A reference to the auto-generated KeyVault HTTP client.\n   */\n  private readonly client: KeyVaultClient;\n\n  /**\n   * @internal\n   * @ignore\n   * A self reference that bypasses private methods, for the pollers.\n   */\n  private readonly pollerClient: SecretClientInterface = {\n    recoverDeletedSecret: this.recoverDeletedSecret.bind(this),\n    getSecret: this.getSecret.bind(this),\n    deleteSecret: this.deleteSecret.bind(this),\n    getDeletedSecret: this.getDeletedSecret.bind(this)\n  };\n\n  /**\n   * Creates an instance of SecretClient.\n   *\n   * Example usage:\n   * ```ts\n   * import { SecretClient } from \"@azure/keyvault-secrets\";\n   * import { DefaultAzureCredential } from \"@azure/identity\";\n   *\n   * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;\n   * let credentials = new DefaultAzureCredential();\n   *\n   * let client = new SecretClient(vaultUrl, credentials);\n   * ```\n   * @param {string} vaultUrl the base URL to the vault.\n   * @param {TokenCredential} credential An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the @azure/identity package to create a credential that suits your needs.\n   * @param {PipelineOptions} [pipelineOptions] Optional. Pipeline options used to configure Key Vault API requests.\n   *                                                         Omit this parameter to use the default pipeline configuration.\n   * @memberof SecretClient\n   */\n  constructor(\n    vaultUrl: string,\n    credential: TokenCredential,\n    pipelineOptions: SecretClientOptions = {}\n  ) {\n    this.vaultUrl = vaultUrl;\n\n    const libInfo = `azsdk-js-keyvault-secrets/${SDK_VERSION}`;\n\n    const userAgentOptions = pipelineOptions.userAgentOptions;\n\n    pipelineOptions.userAgentOptions = {\n      ...pipelineOptions.userAgentOptions,\n      userAgentPrefix:\n        userAgentOptions && userAgentOptions.userAgentPrefix\n          ? `${userAgentOptions.userAgentPrefix} ${libInfo}`\n          : libInfo\n    };\n\n    const authPolicy = isTokenCredential(credential)\n      ? challengeBasedAuthenticationPolicy(credential)\n      : signingPolicy(credential);\n\n    const internalPipelineOptions = {\n      ...pipelineOptions,\n      ...{\n        loggingOptions: {\n          logger: logger.info,\n          logPolicyOptions: {\n            allowedHeaderNames: [\n              \"x-ms-keyvault-region\",\n              \"x-ms-keyvault-network-info\",\n              \"x-ms-keyvault-service-version\"\n            ]\n          }\n        }\n      }\n    };\n\n    const pipeline = createPipelineFromOptions(internalPipelineOptions, authPolicy);\n    this.client = new KeyVaultClient(\n      pipelineOptions.serviceVersion || LATEST_API_VERSION,\n      pipeline\n    );\n  }\n\n  /**\n   * The setSecret method adds a secret or secret version to the Azure Key Vault. If the named secret\n   * already exists, Azure Key Vault creates a new version of that secret.\n   * This operation requires the secrets/set permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * await client.setSecret(\"MySecretName\", \"ABC123\");\n   * ```\n   * @summary Adds a secret in a specified key vault.\n   * @param {string} secretName The name of the secret.\n   * @param {string} value The value of the secret.\n   * @param {SetSecretOptions} [options] The optional parameters.\n   */\n  public async setSecret(\n    secretName: string,\n    value: string,\n    options: SetSecretOptions = {}\n  ): Promise<KeyVaultSecret> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n\n    if (requestOptions) {\n      const { enabled, notBefore, expiresOn: expires, ...remainingOptions } = requestOptions;\n      const unflattenedOptions = {\n        ...remainingOptions,\n        secretAttributes: {\n          enabled,\n          notBefore,\n          expires\n        }\n      };\n\n      const span = this.createSpan(\"setSecret\", unflattenedOptions);\n\n      let response: SetSecretResponse;\n      try {\n        response = await this.client.setSecret(\n          this.vaultUrl,\n          secretName,\n          value,\n          this.setParentSpan(span, unflattenedOptions)\n        );\n      } finally {\n        span.end();\n      }\n\n      return this.getSecretFromSecretBundle(response);\n    } else {\n      const response = await this.client.setSecret(\n        this.vaultUrl,\n        secretName,\n        value,\n        requestOptions\n      );\n      return this.getSecretFromSecretBundle(response);\n    }\n  }\n\n  /**\n   * Deletes a secret stored in Azure Key Vault.\n   * This function returns a Long Running Operation poller that allows you to wait indefinitely until the secret is deleted.\n   *\n   * This operation requires the secrets/delete permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new SecretClient(url, credentials);\n   * await client.setSecret(\"MySecretName\", \"ABC123\");\n   *\n   * const deletePoller = await client.beginDeleteSecret(\"MySecretName\");\n   *\n   * // Serializing the poller\n   * const serialized = deletePoller.toString();\n   *\n   * // A new poller can be created with:\n   * // const newPoller = await client.beginDeleteSecret(\"MySecretName\", { resumeFrom: serialized });\n   *\n   * // Waiting until it's done\n   * const deletedSecret = await deletePoller.pollUntilDone();\n   * console.log(deletedSecret);\n   * ```\n   * @summary Deletes a secret from a specified key vault.\n   * @param {string} secretName The name of the secret.\n   * @param {BeginDeleteSecretOptions} [options] The optional parameters.\n   */\n  public async beginDeleteSecret(\n    name: string,\n    options: BeginDeleteSecretOptions = {}\n  ): Promise<PollerLike<PollOperationState<DeletedSecret>, DeletedSecret>> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const poller = new DeleteSecretPoller({\n      name,\n      client: this.pollerClient,\n      ...options,\n      requestOptions\n    });\n    // This will initialize the poller's operation (the deletion of the secret).\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * The updateSecret method changes specified attributes of an existing stored secret. Properties that\n   * are not specified in the request are left unchanged. The value of a secret itself cannot be\n   * changed. This operation requires the secrets/set permission.\n   *\n   * Example usage:\n   * ```ts\n   * let secretName = \"MySecretName\";\n   * let client = new SecretClient(url, credentials);\n   * let secret = await client.getSecret(secretName);\n   * await client.updateSecretProperties(secretName, secret.properties.version, { enabled: false });\n   * ```\n   * @summary Updates the attributes associated with a specified secret in a given key vault.\n   * @param {string} secretName The name of the secret.\n   * @param {string} secretVersion The version of the secret.\n   * @param {UpdateSecretPropertiesOptions} [options] The optional parameters.\n   */\n  public async updateSecretProperties(\n    secretName: string,\n    secretVersion: string,\n    options: UpdateSecretPropertiesOptions = {}\n  ): Promise<SecretProperties> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n\n    if (requestOptions) {\n      const { enabled, notBefore, expiresOn: expires, ...remainingOptions } = requestOptions;\n      const unflattenedOptions = {\n        ...remainingOptions,\n        secretAttributes: {\n          enabled,\n          notBefore,\n          expires\n        }\n      };\n\n      const span = this.createSpan(\"updateSecretProperties\", unflattenedOptions);\n\n      let response: UpdateSecretResponse;\n\n      try {\n        response = await this.client.updateSecret(\n          this.vaultUrl,\n          secretName,\n          secretVersion,\n          this.setParentSpan(span, unflattenedOptions)\n        );\n      } finally {\n        span.end();\n      }\n\n      return this.getSecretFromSecretBundle(response).properties;\n    } else {\n      const response = await this.client.updateSecret(\n        this.vaultUrl,\n        secretName,\n        secretVersion,\n        requestOptions\n      );\n      return this.getSecretFromSecretBundle(response).properties;\n    }\n  }\n\n  /**\n   * The getSecret method is applicable to any secret stored in Azure Key Vault. This operation requires\n   * the secrets/get permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * let secret = await client.getSecret(\"MySecretName\");\n   * ```\n   * @summary Get a specified secret from a given key vault.\n   * @param {string} secretName The name of the secret.\n   * @param {GetSecretOptions} [options] The optional parameters.\n   */\n  public async getSecret(\n    secretName: string,\n    options: GetSecretOptions = {}\n  ): Promise<KeyVaultSecret> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"getSecret\", requestOptions);\n\n    let response: GetSecretResponse;\n    try {\n      response = await this.client.getSecret(\n        this.vaultUrl,\n        secretName,\n        options && options.version ? options.version : \"\",\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return this.getSecretFromSecretBundle(response);\n  }\n\n  /**\n   * The getDeletedSecret method returns the specified deleted secret along with its attributes.\n   * This operation requires the secrets/get permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * await client.getDeletedSecret(\"MyDeletedSecret\");\n   * ```\n   * @summary Gets the specified deleted secret.\n   * @param {string} secretName The name of the secret.\n   * @param {GetDeletedSecretOptions} [options] The optional parameters.\n   */\n  public async getDeletedSecret(\n    secretName: string,\n    options: GetDeletedSecretOptions = {}\n  ): Promise<DeletedSecret> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"getDeletedSecret\", requestOptions);\n\n    let response: GetDeletedSecretResponse;\n\n    try {\n      response = await this.client.getDeletedSecret(\n        this.vaultUrl,\n        secretName,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return this.getSecretFromSecretBundle(response);\n  }\n\n  /**\n   * The purge deleted secret operation removes the secret permanently, without the possibility of\n   * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation\n   * requires the secrets/purge permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new SecretClient(url, credentials);\n   * const deletePoller = await client.beginDeleteSecret(\"MySecretName\");\n   * await deletePoller.pollUntilDone();\n   * await client.purgeDeletedSecret(\"MySecretName\");\n   * ```\n   * @summary Permanently deletes the specified secret.\n   * @param {string} secretName The name of the secret.\n   * @param {PurgeDeletedSecretOptions} [options] The optional parameters.\n   */\n  public async purgeDeletedSecret(\n    secretName: string,\n    options: PurgeDeletedSecretOptions = {}\n  ): Promise<void> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"purgeDeletedSecret\", requestOptions);\n\n    try {\n      await this.client.purgeDeletedSecret(\n        this.vaultUrl,\n        secretName,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Recovers the deleted secret in the specified vault.\n   * This function returns a Long Running Operation poller that allows you to wait indefinitely until the secret is recovered.\n   *\n   * This operation requires the secrets/recover permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new SecretClient(url, credentials);\n   * await client.setSecret(\"MySecretName\", \"ABC123\");\n   *\n   * const deletePoller = await client.beginDeleteSecret(\"MySecretName\");\n   * await deletePoller.pollUntilDone();\n   *\n   * const recoverPoller = await client.beginRecoverDeletedSecret(\"MySecretName\");\n   *\n   * // Serializing the poller\n   * const serialized = recoverPoller.toString();\n   *\n   * // A new poller can be created with:\n   * // const newPoller = await client.beginRecoverDeletedSecret(\"MySecretName\", { resumeFrom: serialized });\n   *\n   * // Waiting until it's done\n   * const deletedSecret = await recoverPoller.pollUntilDone();\n   * console.log(deletedSecret);\n   * ```\n   * @summary Recovers the deleted secret to the latest version.\n   * @param {string} secretName The name of the deleted secret.\n   * @param {BeginRecoverDeletedSecretOptions} [options] The optional parameters.\n   */\n  public async beginRecoverDeletedSecret(\n    name: string,\n    options: BeginRecoverDeletedSecretOptions = {}\n  ): Promise<PollerLike<PollOperationState<SecretProperties>, SecretProperties>> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n\n    const poller = new RecoverDeletedSecretPoller({\n      name,\n      client: this.pollerClient,\n      ...options,\n      requestOptions\n    });\n\n    // This will initialize the poller's operation (the recovery of the deleted secret).\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Requests that a backup of the specified secret be downloaded to the client. All versions of the\n   * secret will be downloaded. This operation requires the secrets/backup permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * let backupResult = await client.backupSecret(\"MySecretName\");\n   * ```\n   * @summary Backs up the specified secret.\n   * @param {string} secretName The name of the secret.\n   * @param {BackupSecretOptions} [options] The optional parameters.\n   */\n  public async backupSecret(\n    secretName: string,\n    options: BackupSecretOptions = {}\n  ): Promise<Uint8Array | undefined> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"backupSecret\", requestOptions);\n\n    let response: BackupSecretResponse;\n\n    try {\n      response = await this.client.backupSecret(\n        this.vaultUrl,\n        secretName,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n    return response.value;\n  }\n\n  /**\n   * Restores a backed up secret, and all its versions, to a vault. This operation requires the\n   * secrets/restore permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * let mySecretBundle = await client.backupSecret(\"MySecretName\");\n   * // ...\n   * await client.restoreSecretBackup(mySecretBundle);\n   * ```\n   * @summary Restores a backed up secret to a vault.\n   * @param {Uint8Array} secretBundleBackup The backup blob associated with a secret bundle.\n   * @param {RestoreSecretResponse} [options] The optional parameters.\n   */\n  public async restoreSecretBackup(\n    secretBundleBackup: Uint8Array,\n    options: RestoreSecretBackupOptions = {}\n  ): Promise<SecretProperties> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"restoreSecretBackup\", requestOptions);\n\n    let response: RestoreSecretResponse;\n\n    try {\n      response = await this.client.restoreSecret(\n        this.vaultUrl,\n        secretBundleBackup,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return this.getSecretFromSecretBundle(response).properties;\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Sends a delete request for the given KeyVault Secret's name to the KeyVault service.\n   * Since the KeyVault Secret won't be immediately deleted, we have {@link beginDeleteSecret}.\n   * @param {string} name The name of the KeyVault Secret.\n   * @param {RequestOptionsBase} [options] Optional parameters for the underlying HTTP request.\n   */\n  private async deleteSecret(\n    secretName: string,\n    options: DeleteSecretOptions = {}\n  ): Promise<DeletedSecret> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"deleteSecret\", requestOptions);\n\n    let response: DeleteSecretResponse;\n    try {\n      response = await this.client.deleteSecret(\n        this.vaultUrl,\n        secretName,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return this.getSecretFromSecretBundle(response);\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Sends a request to recover a deleted KeyVault Secret based on the given name.\n   * Since the KeyVault Secret won't be immediately recover the deleted secret, we have {@link beginRecoverDeletedSecret}.\n   * @param {string} name The name of the KeyVault Secret.\n   * @param {RecoverDeletedKeyOptions} [options] Optional parameters for the underlying HTTP request.\n   */\n  private async recoverDeletedSecret(\n    secretName: string,\n    options: RecoverDeletedSecretOptions = {}\n  ): Promise<SecretProperties> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"recoverDeletedSecret\", requestOptions);\n\n    let properties: SecretProperties;\n\n    try {\n      const response = await this.client.recoverDeletedSecret(\n        this.vaultUrl,\n        secretName,\n        this.setParentSpan(span, requestOptions)\n      );\n      properties = this.getSecretFromSecretBundle(response).properties;\n    } finally {\n      span.end();\n    }\n\n    return properties;\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the pagination of {@link listPropertiesOfSecretVersions}.\n   * @param {string} name The name of the KeyVault Secret.\n   * @param {PageSettings} continuationState An object that indicates the position of the paginated request.\n   * @param {ListPropertiesOfSecretVersionsOptions} [options] Optional parameters for the underlying HTTP request.\n   */\n  private async *listPropertiesOfSecretVersionsPage(\n    secretName: string,\n    continuationState: PageSettings,\n    options: ListPropertiesOfSecretVersionsOptions = {}\n  ): AsyncIterableIterator<SecretProperties[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: KeyVaultClientGetSecretsOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options\n      };\n      const currentSetResponse = await this.client.getSecretVersions(\n        this.vaultUrl,\n        secretName,\n        optionsComplete\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(\n          (bundle) => this.getSecretFromSecretBundle(bundle).properties\n        );\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await this.client.getSecretVersions(\n        continuationState.continuationToken,\n        secretName,\n        options\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(\n          (bundle) => this.getSecretFromSecretBundle(bundle).properties\n        );\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the iteration of all the available results of {@link listPropertiesOfSecretVersions}.\n   * @param {string} name The name of the KeyVault Secret.\n   * @param {ListPropertiesOfSecretVersionsOptions} [options] Optional parameters for the underlying HTTP request.\n   */\n  private async *listPropertiesOfSecretVersionsAll(\n    secretName: string,\n    options: ListPropertiesOfSecretVersionsOptions = {}\n  ): AsyncIterableIterator<SecretProperties> {\n    const f = {};\n\n    for await (const page of this.listPropertiesOfSecretVersionsPage(secretName, f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates all versions of the given secret in the vault. The full secret identifier and attributes are provided\n   * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * for await (const secretProperties of client.listPropertiesOfSecretVersions(\"MySecretName\")) {\n   *   const secret = await client.getSecret(secretProperties.name);\n   *   console.log(\"secret version: \", secret);\n   * }\n   * ```\n   * @param {string} secretName Name of the secret to fetch versions for.\n   * @param {ListPropertiesOfSecretVersionsOptions} [options] The optional parameters.\n   */\n  public listPropertiesOfSecretVersions(\n    secretName: string,\n    options: ListPropertiesOfSecretVersionsOptions = {}\n  ): PagedAsyncIterableIterator<SecretProperties> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"listPropertiesOfSecretVersions\", requestOptions);\n    const updatedOptions: ListPropertiesOfSecretVersionsOptions = {\n      ...requestOptions,\n      ...this.setParentSpan(span, requestOptions)\n    };\n\n    const iter = this.listPropertiesOfSecretVersionsAll(secretName, updatedOptions);\n\n    span.end();\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) =>\n        this.listPropertiesOfSecretVersionsPage(secretName, settings, updatedOptions)\n    };\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the pagination of {@link listPropertiesOfSecrets}.\n   * @param {PageSettings} continuationState An object that indicates the position of the paginated request.\n   * @param {ListPropertiesOfSecretsOptions} [options] Optional parameters for the underlying HTTP request.\n   */\n  private async *listPropertiesOfSecretsPage(\n    continuationState: PageSettings,\n    options: ListPropertiesOfSecretsOptions = {}\n  ): AsyncIterableIterator<SecretProperties[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: KeyVaultClientGetSecretsOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options\n      };\n      const currentSetResponse = await this.client.getSecrets(this.vaultUrl, optionsComplete);\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(\n          (bundle) => this.getSecretFromSecretBundle(bundle).properties\n        );\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await this.client.getSecrets(\n        continuationState.continuationToken,\n        options\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(\n          (bundle) => this.getSecretFromSecretBundle(bundle).properties\n        );\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the iteration of all the available results of {@link listPropertiesOfSecrets}.\n   * @param {ListPropertiesOfSecretsOptions} [options] Optional parameters for the underlying HTTP request.\n   */\n  private async *listPropertiesOfSecretsAll(\n    options: ListPropertiesOfSecretsOptions = {}\n  ): AsyncIterableIterator<SecretProperties> {\n    const f = {};\n\n    for await (const page of this.listPropertiesOfSecretsPage(f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates the latest version of all secrets in the vault.  The full secret identifier and attributes are provided\n   * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * for await (const secretProperties of client.listPropertiesOfSecrets()) {\n   *   const secret = await client.getSecret(secretProperties.name);\n   *   console.log(\"secret: \", secret);\n   * }\n   * ```\n   * @summary List all secrets in the vault.\n   * @param {ListPropertiesOfSecretsOptions} [options] The optional parameters.\n   */\n  public listPropertiesOfSecrets(\n    options: ListPropertiesOfSecretsOptions = {}\n  ): PagedAsyncIterableIterator<SecretProperties> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"listPropertiesOfSecrets\", requestOptions);\n    const updatedOptions: ListPropertiesOfSecretsOptions = {\n      ...requestOptions,\n      ...this.setParentSpan(span, requestOptions)\n    };\n\n    const iter = this.listPropertiesOfSecretsAll(updatedOptions);\n\n    span.end();\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) =>\n        this.listPropertiesOfSecretsPage(settings, updatedOptions)\n    };\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the pagination of {@link listDeletedSecrets}.\n   * @param {PageSettings} continuationState An object that indicates the position of the paginated request.\n   * @param {ListDeletedSecretsOptions} [options] Optional parameters for the underlying HTTP request.\n   */\n  private async *listDeletedSecretsPage(\n    continuationState: PageSettings,\n    options: ListDeletedSecretsOptions = {}\n  ): AsyncIterableIterator<DeletedSecret[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: KeyVaultClientGetSecretsOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options\n      };\n      const currentSetResponse = await this.client.getDeletedSecrets(\n        this.vaultUrl,\n        optionsComplete\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map((bundle) => this.getSecretFromSecretBundle(bundle));\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await this.client.getDeletedSecrets(\n        continuationState.continuationToken,\n        options\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map((bundle) => this.getSecretFromSecretBundle(bundle));\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the iteration of all the available results of {@link listDeletedSecrets}.\n   * @param {ListDeletedSecretsOptions} [options] Optional parameters for the underlying HTTP request.\n   */\n  private async *listDeletedSecretsAll(\n    options: ListDeletedSecretsOptions = {}\n  ): AsyncIterableIterator<DeletedSecret> {\n    const f = {};\n\n    for await (const page of this.listDeletedSecretsPage(f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates the deleted secrets in the vault.  The full secret identifier and attributes are provided\n   * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * for await (const deletedSecret of client.listDeletedSecrets()) {\n   *   console.log(\"deleted secret: \", deletedSecret);\n   * }\n   * ```\n   * @summary List all secrets in the vault.\n   * @param {ListDeletedSecretsOptions} [options] The optional parameters.\n   */\n  public listDeletedSecrets(\n    options: ListDeletedSecretsOptions = {}\n  ): PagedAsyncIterableIterator<DeletedSecret> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"listDeletedSecrets\", requestOptions);\n    const updatedOptions: ListDeletedSecretsOptions = {\n      ...requestOptions,\n      ...this.setParentSpan(span, requestOptions)\n    };\n\n    const iter = this.listDeletedSecretsAll(updatedOptions);\n\n    span.end();\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) => this.listDeletedSecretsPage(settings, updatedOptions)\n    };\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Shapes the exposed {@link KeyVaultSecret} based on either a received secret bundle or deleted secret bundle.\n   */\n  private getSecretFromSecretBundle(bundle: SecretBundle | DeletedSecretBundle): KeyVaultSecret {\n    const secretBundle = bundle as SecretBundle;\n    const deletedSecretBundle = bundle as DeletedSecretBundle;\n    const parsedId = parseKeyvaultEntityIdentifier(\"secrets\", secretBundle.id);\n\n    const attributes = secretBundle.attributes;\n    delete secretBundle.attributes;\n\n    const resultObject: KeyVaultSecret & DeletedSecret = {\n      value: secretBundle.value,\n      name: parsedId.name,\n      properties: {\n        expiresOn: (attributes as any).expires,\n        createdOn: (attributes as any).created,\n        updatedOn: (attributes as any).updated,\n        ...secretBundle,\n        ...parsedId,\n        ...attributes\n      }\n    };\n\n    if (deletedSecretBundle.deletedDate) {\n      resultObject.properties.deletedOn = deletedSecretBundle.deletedDate;\n      delete (resultObject.properties as any).deletedDate;\n    }\n\n    if (attributes) {\n      if ((attributes as any).vaultUrl) {\n        delete (resultObject.properties as any).vaultUrl;\n      }\n\n      if (attributes.expires) {\n        delete (resultObject.properties as any).expires;\n      }\n\n      if (attributes.created) {\n        delete (resultObject.properties as any).created;\n      }\n\n      if (attributes.updated) {\n        delete (resultObject.properties as any).updated;\n      }\n    }\n\n    return resultObject;\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Creates a span using the tracer that was set by the user\n   * @param {string} methodName The name of the method creating the span.\n   * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.\n   */\n  private createSpan(methodName: string, requestOptions: RequestOptionsBase = {}): Span {\n    const tracer = getTracer();\n    const span = tracer.startSpan(methodName, requestOptions && requestOptions.spanOptions);\n    span.setAttribute(\"az.namespace\", \"Microsoft.KeyVault\");\n    return span;\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Returns updated HTTP options with the given span as the parent of future spans,\n   * if applicable.\n   * @param {Span} span The span for the current operation.\n   * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.\n   */\n  private setParentSpan(span: Span, options: RequestOptionsBase = {}): RequestOptionsBase {\n    if (span.isRecording()) {\n      const spanOptions = options.spanOptions || {};\n      return {\n        ...options,\n        spanOptions: {\n          ...spanOptions,\n          parent: span.context(),\n          attributes: {\n            ...spanOptions.attributes,\n            \"az.namespace\": \"Microsoft.KeyVault\"\n          }\n        }\n      };\n    } else {\n      return options;\n    }\n  }\n}\n"],"names":["createClientLogger","coreHttp.ServiceClient","coreHttp.getDefaultUserAgentValue","coreHttp.Serializer","Parameters.vaultBaseUrl","Parameters.secretName0","Parameters.apiVersion","Mappers.SecretSetParameters","Mappers.SecretBundle","Mappers.KeyVaultError","Parameters.secretName1","Mappers.DeletedSecretBundle","Parameters.secretVersion","Mappers.SecretUpdateParameters","Parameters.maxresults","Mappers.SecretListResult","Mappers.DeletedSecretListResult","Mappers.BackupSecretResult","Mappers.SecretRestoreParameters","ExpiringAccessTokenCache","BaseRequestPolicy","Constants","Poller","delay","update","cancel","toString","url.parse","isTokenCredential","signingPolicy","createPipelineFromOptions","operationOptionsToRequestOptionsBase","__asyncValues","parseKeyvaultEntityIdentifier","getTracer"],"mappings":"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"}