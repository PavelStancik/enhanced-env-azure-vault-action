/*!
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 * 
 * Azure KeyVault Secrets SDK for JavaScript - 4.1.0
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreHttp = require('@azure/core-http');
var coreTracing = require('@azure/core-tracing');
var logger$1 = require('@azure/logger');
require('@azure/core-paging');
var coreLro = require('@azure/core-lro');
var url = require('url');

// Copyright (c) Microsoft Corporation.
/**
 * The @azure/logger configuration for this package.
 */
const logger = logger$1.createClientLogger("keyvault-secrets");

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const Attributes = {
    serializedName: "Attributes",
    type: {
        name: "Composite",
        className: "Attributes",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            notBefore: {
                serializedName: "nbf",
                type: {
                    name: "UnixTime"
                }
            },
            expires: {
                serializedName: "exp",
                type: {
                    name: "UnixTime"
                }
            },
            created: {
                readOnly: true,
                serializedName: "created",
                type: {
                    name: "UnixTime"
                }
            },
            updated: {
                readOnly: true,
                serializedName: "updated",
                type: {
                    name: "UnixTime"
                }
            }
        }
    }
};
const SecretAttributes = {
    serializedName: "SecretAttributes",
    type: {
        name: "Composite",
        className: "SecretAttributes",
        modelProperties: Object.assign(Object.assign({}, Attributes.type.modelProperties), { recoverableDays: {
                readOnly: true,
                serializedName: "recoverableDays",
                type: {
                    name: "Number"
                }
            }, recoveryLevel: {
                nullable: false,
                readOnly: true,
                serializedName: "recoveryLevel",
                type: {
                    name: "String"
                }
            } })
    }
};
const SecretBundle = {
    serializedName: "SecretBundle",
    type: {
        name: "Composite",
        className: "SecretBundle",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SecretAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            kid: {
                readOnly: true,
                serializedName: "kid",
                type: {
                    name: "String"
                }
            },
            managed: {
                readOnly: true,
                serializedName: "managed",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const SecretItem = {
    serializedName: "SecretItem",
    type: {
        name: "Composite",
        className: "SecretItem",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SecretAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            managed: {
                readOnly: true,
                serializedName: "managed",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const DeletedSecretBundle = {
    serializedName: "DeletedSecretBundle",
    type: {
        name: "Composite",
        className: "DeletedSecretBundle",
        modelProperties: Object.assign(Object.assign({}, SecretBundle.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
const DeletedSecretItem = {
    serializedName: "DeletedSecretItem",
    type: {
        name: "Composite",
        className: "DeletedSecretItem",
        modelProperties: Object.assign(Object.assign({}, SecretItem.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
const SecretRestoreParameters = {
    serializedName: "SecretRestoreParameters",
    type: {
        name: "Composite",
        className: "SecretRestoreParameters",
        modelProperties: {
            secretBundleBackup: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
const SecretProperties = {
    serializedName: "SecretProperties",
    type: {
        name: "Composite",
        className: "SecretProperties",
        modelProperties: {
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecretSetParameters = {
    serializedName: "SecretSetParameters",
    type: {
        name: "Composite",
        className: "SecretSetParameters",
        modelProperties: {
            value: {
                required: true,
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            secretAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SecretAttributes"
                }
            }
        }
    }
};
const SecretUpdateParameters = {
    serializedName: "SecretUpdateParameters",
    type: {
        name: "Composite",
        className: "SecretUpdateParameters",
        modelProperties: {
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            secretAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SecretAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const SecretListResult = {
    serializedName: "SecretListResult",
    type: {
        name: "Composite",
        className: "SecretListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecretItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeletedSecretListResult = {
    serializedName: "DeletedSecretListResult",
    type: {
        name: "Composite",
        className: "DeletedSecretListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedSecretItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BackupSecretResult = {
    serializedName: "BackupSecretResult",
    type: {
        name: "Composite",
        className: "BackupSecretResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
const ErrorModel = {
    serializedName: "Error",
    type: {
        name: "Composite",
        className: "ErrorModel",
        modelProperties: {
            code: {
                readOnly: true,
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                readOnly: true,
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            innerError: {
                readOnly: true,
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
const KeyVaultError = {
    serializedName: "KeyVaultError",
    type: {
        name: "Composite",
        className: "KeyVaultError",
        modelProperties: {
            error: {
                readOnly: true,
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Attributes: Attributes,
    SecretAttributes: SecretAttributes,
    SecretBundle: SecretBundle,
    SecretItem: SecretItem,
    DeletedSecretBundle: DeletedSecretBundle,
    DeletedSecretItem: DeletedSecretItem,
    SecretRestoreParameters: SecretRestoreParameters,
    SecretProperties: SecretProperties,
    SecretSetParameters: SecretSetParameters,
    SecretUpdateParameters: SecretUpdateParameters,
    SecretListResult: SecretListResult,
    DeletedSecretListResult: DeletedSecretListResult,
    BackupSecretResult: BackupSecretResult,
    ErrorModel: ErrorModel,
    KeyVaultError: KeyVaultError
});

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        required: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const maxresults = {
    parameterPath: [
        "options",
        "maxresults"
    ],
    mapper: {
        serializedName: "maxresults",
        constraints: {
            InclusiveMaximum: 25,
            InclusiveMinimum: 1
        },
        type: {
            name: "Number"
        }
    }
};
const secretName0 = {
    parameterPath: "secretName",
    mapper: {
        required: true,
        serializedName: "secret-name",
        constraints: {
            Pattern: /^[0-9a-zA-Z-]+$/
        },
        type: {
            name: "String"
        }
    }
};
const secretName1 = {
    parameterPath: "secretName",
    mapper: {
        required: true,
        serializedName: "secret-name",
        type: {
            name: "String"
        }
    }
};
const secretVersion = {
    parameterPath: "secretVersion",
    mapper: {
        required: true,
        serializedName: "secret-version",
        type: {
            name: "String"
        }
    }
};
const vaultBaseUrl = {
    parameterPath: "vaultBaseUrl",
    mapper: {
        required: true,
        serializedName: "vaultBaseUrl",
        defaultValue: '',
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
const packageName = "@azure/keyvault-secrets";
const packageVersion = "4.1.0";
class KeyVaultClientContext extends coreHttp.ServiceClient {
    /**
     * Initializes a new instance of the KeyVaultClientContext class.
     * @param apiVersion Client API version.
     * @param [options] The parameter options
     */
    constructor(apiVersion, options) {
        if (apiVersion == undefined) {
            throw new Error("'apiVersion' cannot be null.");
        }
        if (!options) {
            options = {};
        }
        if (!options.userAgent) {
            const defaultUserAgent = coreHttp.getDefaultUserAgentValue();
            options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;
        }
        super(undefined, options);
        this.baseUri = "{vaultBaseUrl}";
        this.requestContentType = "application/json; charset=utf-8";
        this.apiVersion = apiVersion;
    }
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
class KeyVaultClient extends KeyVaultClientContext {
    /**
     * Initializes a new instance of the KeyVaultClient class.
     * @param apiVersion Client API version.
     * @param [options] The parameter options
     */
    constructor(apiVersion, options) {
        super(apiVersion, options);
    }
    setSecret(vaultBaseUrl, secretName, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            secretName,
            value,
            options
        }, setSecretOperationSpec, callback);
    }
    deleteSecret(vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            secretName,
            options
        }, deleteSecretOperationSpec, callback);
    }
    updateSecret(vaultBaseUrl, secretName, secretVersion, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            secretName,
            secretVersion,
            options
        }, updateSecretOperationSpec, callback);
    }
    getSecret(vaultBaseUrl, secretName, secretVersion, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            secretName,
            secretVersion,
            options
        }, getSecretOperationSpec, callback);
    }
    getSecrets(vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            options
        }, getSecretsOperationSpec, callback);
    }
    getSecretVersions(vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            secretName,
            options
        }, getSecretVersionsOperationSpec, callback);
    }
    getDeletedSecrets(vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            options
        }, getDeletedSecretsOperationSpec, callback);
    }
    getDeletedSecret(vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            secretName,
            options
        }, getDeletedSecretOperationSpec, callback);
    }
    purgeDeletedSecret(vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            secretName,
            options
        }, purgeDeletedSecretOperationSpec, callback);
    }
    recoverDeletedSecret(vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            secretName,
            options
        }, recoverDeletedSecretOperationSpec, callback);
    }
    backupSecret(vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            secretName,
            options
        }, backupSecretOperationSpec, callback);
    }
    restoreSecret(vaultBaseUrl, secretBundleBackup, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl,
            secretBundleBackup,
            options
        }, restoreSecretOperationSpec, callback);
    }
}
// Operation Specifications
const serializer = new coreHttp.Serializer(Mappers);
const setSecretOperationSpec = {
    httpMethod: "PUT",
    path: "secrets/{secret-name}",
    urlParameters: [
        vaultBaseUrl,
        secretName0
    ],
    queryParameters: [
        apiVersion
    ],
    requestBody: {
        parameterPath: {
            value: "value",
            tags: [
                "options",
                "tags"
            ],
            contentType: [
                "options",
                "contentType"
            ],
            secretAttributes: [
                "options",
                "secretAttributes"
            ]
        },
        mapper: Object.assign(Object.assign({}, SecretSetParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: SecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const deleteSecretOperationSpec = {
    httpMethod: "DELETE",
    path: "secrets/{secret-name}",
    urlParameters: [
        vaultBaseUrl,
        secretName1
    ],
    queryParameters: [
        apiVersion
    ],
    responses: {
        200: {
            bodyMapper: DeletedSecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const updateSecretOperationSpec = {
    httpMethod: "PATCH",
    path: "secrets/{secret-name}/{secret-version}",
    urlParameters: [
        vaultBaseUrl,
        secretName1,
        secretVersion
    ],
    queryParameters: [
        apiVersion
    ],
    requestBody: {
        parameterPath: {
            contentType: [
                "options",
                "contentType"
            ],
            secretAttributes: [
                "options",
                "secretAttributes"
            ],
            tags: [
                "options",
                "tags"
            ]
        },
        mapper: Object.assign(Object.assign({}, SecretUpdateParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: SecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const getSecretOperationSpec = {
    httpMethod: "GET",
    path: "secrets/{secret-name}/{secret-version}",
    urlParameters: [
        vaultBaseUrl,
        secretName1,
        secretVersion
    ],
    queryParameters: [
        apiVersion
    ],
    responses: {
        200: {
            bodyMapper: SecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const getSecretsOperationSpec = {
    httpMethod: "GET",
    path: "secrets",
    urlParameters: [
        vaultBaseUrl
    ],
    queryParameters: [
        maxresults,
        apiVersion
    ],
    responses: {
        200: {
            bodyMapper: SecretListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const getSecretVersionsOperationSpec = {
    httpMethod: "GET",
    path: "secrets/{secret-name}/versions",
    urlParameters: [
        vaultBaseUrl,
        secretName1
    ],
    queryParameters: [
        maxresults,
        apiVersion
    ],
    responses: {
        200: {
            bodyMapper: SecretListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const getDeletedSecretsOperationSpec = {
    httpMethod: "GET",
    path: "deletedsecrets",
    urlParameters: [
        vaultBaseUrl
    ],
    queryParameters: [
        maxresults,
        apiVersion
    ],
    responses: {
        200: {
            bodyMapper: DeletedSecretListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const getDeletedSecretOperationSpec = {
    httpMethod: "GET",
    path: "deletedsecrets/{secret-name}",
    urlParameters: [
        vaultBaseUrl,
        secretName1
    ],
    queryParameters: [
        apiVersion
    ],
    responses: {
        200: {
            bodyMapper: DeletedSecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const purgeDeletedSecretOperationSpec = {
    httpMethod: "DELETE",
    path: "deletedsecrets/{secret-name}",
    urlParameters: [
        vaultBaseUrl,
        secretName1
    ],
    queryParameters: [
        apiVersion
    ],
    responses: {
        204: {},
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const recoverDeletedSecretOperationSpec = {
    httpMethod: "POST",
    path: "deletedsecrets/{secret-name}/recover",
    urlParameters: [
        vaultBaseUrl,
        secretName1
    ],
    queryParameters: [
        apiVersion
    ],
    responses: {
        200: {
            bodyMapper: SecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const backupSecretOperationSpec = {
    httpMethod: "POST",
    path: "secrets/{secret-name}/backup",
    urlParameters: [
        vaultBaseUrl,
        secretName1
    ],
    queryParameters: [
        apiVersion
    ],
    responses: {
        200: {
            bodyMapper: BackupSecretResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};
const restoreSecretOperationSpec = {
    httpMethod: "POST",
    path: "secrets/restore",
    urlParameters: [
        vaultBaseUrl
    ],
    queryParameters: [
        apiVersion
    ],
    requestBody: {
        parameterPath: {
            secretBundleBackup: "secretBundleBackup"
        },
        mapper: Object.assign(Object.assign({}, SecretRestoreParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: SecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer
};

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
const SDK_VERSION = "4.1.0";

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Representation of the Authentication Challenge
 */
class AuthenticationChallenge {
    constructor(authorization, scope) {
        this.authorization = authorization;
        this.scope = scope;
    }
    /**
     * Checks that this AuthenticationChallenge is equal to another one given.
     * Only compares the scope.
     * This is exactly what C# is doing, as we can see here:
     * https://github.com/Azure/azure-sdk-for-net/blob/70e54b878ff1d01a45266fb3674a396b4ab9c1d2/sdk/keyvault/Azure.Security.KeyVault.Shared/src/ChallengeBasedAuthenticationPolicy.cs#L143-L147
     * @param other The other AuthenticationChallenge
     */
    equalTo(other) {
        return other
            ? this.scope.toLowerCase() === other.scope.toLowerCase() &&
                this.authorization.toLowerCase() === other.authorization.toLowerCase()
            : false;
    }
}
/**
 * Helps keep a copy of any previous authentication challenges,
 * so that we can compare on any further request.
 */
class AuthenticationChallengeCache {
    setCachedChallenge(challenge) {
        this.challenge = challenge;
    }
}
/**
 * Creates a new ChallengeBasedAuthenticationPolicy factory.
 *
 * @param credential The TokenCredential implementation that can supply the challenge token.
 */
function challengeBasedAuthenticationPolicy(credential) {
    const tokenCache = new coreHttp.ExpiringAccessTokenCache();
    const challengeCache = new AuthenticationChallengeCache();
    return {
        create: (nextPolicy, options) => {
            return new ChallengeBasedAuthenticationPolicy(nextPolicy, options, credential, tokenCache, challengeCache);
        },
    };
}
/**
 * Parses an WWW-Authenticate response.
 * This transforms a string value like:
 * `Bearer authorization="some_authorization", resource="https://some.url"`
 * into an object like:
 * `{ authorization: "some_authorization", resource: "https://some.url" }`
 * @param wwwAuthenticate string value in the WWW-Authenticate header
 */
function parseWWWAuthenticate(wwwAuthenticate) {
    // First we split the string by either `, ` or ` `.
    const parts = wwwAuthenticate.split(/,* +/);
    // Then we only keep the strings with an equal sign after a word and before a quote.
    // also splitting these sections by their equal sign
    const keyValues = parts.reduce((parts, str) => (str.match(/\w="/) ? [...parts, str.split("=")] : parts), []);
    // Then we transform these key-value pairs back into an object.
    const parsed = keyValues.reduce((result, [key, value]) => (Object.assign(Object.assign({}, result), { [key]: value.slice(1, -1) })), {});
    return parsed;
}
/**
 *
 * Provides a RequestPolicy that can request a token from a TokenCredential
 * implementation and then apply it to the Authorization header of a request
 * as a Bearer token.
 *
 */
class ChallengeBasedAuthenticationPolicy extends coreHttp.BaseRequestPolicy {
    /**
     * Creates a new ChallengeBasedAuthenticationPolicy object.
     *
     * @param nextPolicy The next RequestPolicy in the request pipeline.
     * @param options Options for this RequestPolicy.
     * @param credential The TokenCredential implementation that can supply the bearer token.
     * @param tokenCache The cache for the most recent AccessToken returned by the TokenCredential.
     */
    constructor(nextPolicy, options, credential, tokenCache, challengeCache) {
        super(nextPolicy, options);
        this.credential = credential;
        this.tokenCache = tokenCache;
        this.challengeCache = challengeCache;
        this.parseWWWAuthenticate = parseWWWAuthenticate;
    }
    /**
     * Gets or updates the token from the token cache into the headers of the received web resource.
     */
    loadToken(webResource) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let accessToken = this.tokenCache.getCachedToken();
            // If there's no cached token in the cache, we try to get a new one.
            if (accessToken === undefined) {
                const receivedToken = yield this.credential.getToken(this.challengeCache.challenge.scope);
                accessToken = receivedToken || undefined;
                this.tokenCache.setCachedToken(accessToken);
            }
            if (accessToken) {
                webResource.headers.set(coreHttp.Constants.HeaderConstants.AUTHORIZATION, `Bearer ${accessToken.token}`);
            }
        });
    }
    /**
     * Parses the given WWW-Authenticate header, generates a new AuthenticationChallenge,
     * then if the challenge is different from the one cached, resets the token and forces
     * a re-authentication, otherwise continues with the existing challenge and token.
     * @param wwwAuthenticate Value of the incoming WWW-Authenticate header.
     * @param webResource Ongoing HTTP request.
     */
    regenerateChallenge(wwwAuthenticate, webResource) {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // The challenge based authentication will contain both:
            // - An authorization URI with a token,
            // - The resource to which that token is valid against (also called the scope).
            const parsedWWWAuth = this.parseWWWAuthenticate(wwwAuthenticate);
            const authorization = parsedWWWAuth.authorization;
            const resource = parsedWWWAuth.resource || parsedWWWAuth.scope;
            if (!(authorization && resource)) {
                return this._nextPolicy.sendRequest(webResource);
            }
            const challenge = new AuthenticationChallenge(authorization, resource + "/.default");
            // Either if there's no cached challenge at this point (could have happen in parallel),
            // or if the cached challenge has a different scope,
            // we store the just received challenge and reset the cached token, to force a re-authentication.
            if (!((_a = this.challengeCache.challenge) === null || _a === void 0 ? void 0 : _a.equalTo(challenge))) {
                this.challengeCache.setCachedChallenge(challenge);
                this.tokenCache.setCachedToken(undefined);
            }
            yield this.loadToken(webResource);
            return this._nextPolicy.sendRequest(webResource);
        });
    }
    /**
     * Applies the Bearer token to the request through the Authorization header.
     * @param webResource Ongoing HTTP request.
     */
    sendRequest(webResource) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // Ensure that we're about to use a secure connection.
            if (!webResource.url.startsWith("https:")) {
                throw new Error("The resource address for authorization must use the 'https' protocol.");
            }
            // The next request will happen differently whether we have a challenge or not.
            let response;
            if (this.challengeCache.challenge == undefined) {
                // If there's no challenge in cache, a blank body will start the challenge.
                const originalBody = webResource.body;
                webResource.body = "";
                response = yield this._nextPolicy.sendRequest(webResource);
                webResource.body = originalBody;
            }
            else {
                // If we did have a challenge in memory,
                // we attempt to load the token from the cache into the request before we try to send the request.
                yield this.loadToken(webResource);
                response = yield this._nextPolicy.sendRequest(webResource);
            }
            // If we don't receive a response with a 401 status code,
            // then we can assume this response has nothing to do with the challenge authentication process.
            if (response.status !== 401) {
                return response;
            }
            // If the response status is 401, we only re-authenticate if the WWW-Authenticate header is present.
            const wwwAuthenticate = response.headers.get("WWW-Authenticate");
            if (!wwwAuthenticate) {
                return response;
            }
            // We re-generate the challenge and see if we have to re-authenticate.
            return yield this.regenerateChallenge(wwwAuthenticate, webResource);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @summary Reaches to the service and updates the delete secret's poll operation.
 * @param [options] The optional parameters, which are an abortSignal from @azure/abort-controller and a function that triggers the poller's onProgress function.
 */
function update(options = {}) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        const state = this.state;
        const { name, client } = state;
        const requestOptions = state.requestOptions || {};
        if (options.abortSignal) {
            requestOptions.abortSignal = options.abortSignal;
        }
        if (!state.isStarted) {
            const deletedSecret = yield client.deleteSecret(name, requestOptions);
            state.isStarted = true;
            state.result = deletedSecret;
            if (!deletedSecret.properties.recoveryId) {
                state.isCompleted = true;
            }
        }
        if (!state.isCompleted) {
            try {
                state.result = yield client.getDeletedSecret(name, { requestOptions });
                state.isCompleted = true;
            }
            catch (error) {
                if (error.statusCode === 403) {
                    // At this point, the resource exists but the user doesn't have access to it.
                    state.isCompleted = true;
                }
                else if (error.statusCode !== 404) {
                    state.error = error;
                    state.isCompleted = true;
                }
            }
        }
        return makeDeleteSecretPollOperation(state);
    });
}
/**
 * @summary Reaches to the service and cancels the secret's operation, also updating the secret's poll operation
 * @param [options] The optional parameters, which is only an abortSignal from @azure/abort-controller
 */
function cancel() {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        throw new Error("Canceling the deletion of a secret is not supported.");
    });
}
/**
 * @summary Serializes the create secret's poll operation
 */
function toString() {
    return JSON.stringify({
        state: this.state
    });
}
/**
 * @summary Builds a create secret's poll operation
 * @param [state] A poll operation's state, in case the new one is intended to follow up where the previous one was left.
 */
function makeDeleteSecretPollOperation(state) {
    return {
        state: Object.assign({}, state),
        update,
        cancel,
        toString
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Class that deletes a poller that waits until a secret finishes being deleted
 */
class DeleteSecretPoller extends coreLro.Poller {
    constructor(options) {
        const { client, name, requestOptions, intervalInMs = 2000, resumeFrom } = options;
        let state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        const operation = makeDeleteSecretPollOperation(Object.assign(Object.assign({}, state), { name,
            requestOptions,
            client }));
        super(operation);
        this.intervalInMs = intervalInMs;
    }
    /**
     * The method used by the poller to wait before attempting to update its operation.
     * @memberof DeleteSecretPoller
     */
    delay() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return coreHttp.delay(this.intervalInMs);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @summary Reaches to the service and updates the delete secret's poll operation.
 * @param [options] The optional parameters, which are an abortSignal from @azure/abort-controller and a function that triggers the poller's onProgress function.
 */
function update$1(options = {}) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        const state = this.state;
        const { name, client } = state;
        const requestOptions = state.requestOptions || {};
        if (options.abortSignal) {
            requestOptions.abortSignal = options.abortSignal;
        }
        if (!state.isStarted) {
            try {
                state.result = (yield client.getSecret(name, { requestOptions })).properties;
                state.isCompleted = true;
            }
            catch (_a) {
                // Nothing to do here.
            }
            if (!state.isCompleted) {
                state.result = yield client.recoverDeletedSecret(name, { requestOptions });
                state.isStarted = true;
            }
        }
        if (!state.isCompleted) {
            try {
                state.result = (yield client.getSecret(name, { requestOptions })).properties;
                state.isCompleted = true;
            }
            catch (error) {
                if (error.statusCode === 403) {
                    // At this point, the resource exists but the user doesn't have access to it.
                    state.isCompleted = true;
                }
                else if (error.statusCode !== 404) {
                    state.error = error;
                    state.isCompleted = true;
                }
            }
        }
        return makeRecoverDeletedSecretPollOperation(state);
    });
}
/**
 * @summary Reaches to the service and cancels the secret's operation, also updating the secret's poll operation
 * @param [options] The optional parameters, which is only an abortSignal from @azure/abort-controller
 */
function cancel$1() {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        throw new Error("Canceling the deletion of a secret is not supported.");
    });
}
/**
 * @summary Serializes the create secret's poll operation
 */
function toString$1() {
    return JSON.stringify({
        state: this.state
    });
}
/**
 * @summary Builds a create secret's poll operation
 * @param [state] A poll operation's state, in case the new one is intended to follow up where the previous one was left.
 */
function makeRecoverDeletedSecretPollOperation(state) {
    return {
        state: Object.assign({}, state),
        update: update$1,
        cancel: cancel$1,
        toString: toString$1
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Class that deletes a poller that waits until a secret finishes being deleted
 */
class RecoverDeletedSecretPoller extends coreLro.Poller {
    constructor(options) {
        const { client, name, requestOptions, intervalInMs = 2000, resumeFrom } = options;
        let state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        const operation = makeRecoverDeletedSecretPollOperation(Object.assign(Object.assign({}, state), { name,
            requestOptions,
            client }));
        super(operation);
        this.intervalInMs = intervalInMs;
    }
    /**
     * The method used by the poller to wait before attempting to update its operation.
     * @memberof RecoverDeletedSecretPoller
     */
    delay() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return coreHttp.delay(this.intervalInMs);
        });
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The latest supported KeyVault service API version
 */
const LATEST_API_VERSION = "7.1";

function parseKeyvaultIdentifier(collection, identifier) {
    if (typeof collection != "string" || !(collection = collection.trim())) {
        throw new Error("Invalid collection argument");
    }
    if (typeof identifier != "string" || !(identifier = identifier.trim())) {
        throw new Error("Invalid identifier argument");
    }
    var baseUri;
    try {
        baseUri = url.parse(identifier, true, true);
    }
    catch (e) {
        throw new Error(`Invalid ${collection} identifier: ${identifier}. Not a valid URI`);
    }
    // Path is of the form '/collection/name[/version]'
    var segments = (baseUri.pathname || "").split("/");
    if (segments.length !== 3 && segments.length !== 4) {
        throw new Error(`Invalid ${collection} identifier: ${identifier}. Bad number of segments: ${segments.length}`);
    }
    if (collection !== segments[1]) {
        throw new Error(`Invalid ${collection} identifier: ${identifier}. segment [1] should be "${collection}", found "${segments[1]}"`);
    }
    var vaultUrl = `${baseUri.protocol}//${baseUri.host}`;
    var name = segments[2];
    var version = segments.length === 4 ? segments[3] : undefined;
    return {
        vaultUrl,
        name,
        version
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * The SecretClient provides methods to manage {@link KeyVaultSecret} in
 * the Azure Key Vault. The client supports creating, retrieving, updating,
 * deleting, purging, backing up, restoring and listing KeyVaultSecrets. The
 * client also supports listing {@link DeletedSecret} for a soft-delete enabled Azure
 * Key Vault.
 */
class SecretClient {
    /**
     * Creates an instance of SecretClient.
     *
     * Example usage:
     * ```ts
     * import { SecretClient } from "@azure/keyvault-secrets";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;
     * let credentials = new DefaultAzureCredential();
     *
     * let client = new SecretClient(vaultUrl, credentials);
     * ```
     * @param {string} vaultUrl the base URL to the vault.
     * @param {TokenCredential} credential An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the @azure/identity package to create a credential that suits your needs.
     * @param {PipelineOptions} [pipelineOptions] Optional. Pipeline options used to configure Key Vault API requests.
     *                                                         Omit this parameter to use the default pipeline configuration.
     * @memberof SecretClient
     */
    constructor(vaultUrl, credential, pipelineOptions = {}) {
        /**
         * @internal
         * @ignore
         * A self reference that bypasses private methods, for the pollers.
         */
        this.pollerClient = {
            recoverDeletedSecret: this.recoverDeletedSecret.bind(this),
            getSecret: this.getSecret.bind(this),
            deleteSecret: this.deleteSecret.bind(this),
            getDeletedSecret: this.getDeletedSecret.bind(this)
        };
        this.vaultUrl = vaultUrl;
        const libInfo = `azsdk-js-keyvault-secrets/${SDK_VERSION}`;
        const userAgentOptions = pipelineOptions.userAgentOptions;
        pipelineOptions.userAgentOptions = Object.assign(Object.assign({}, pipelineOptions.userAgentOptions), { userAgentPrefix: userAgentOptions && userAgentOptions.userAgentPrefix
                ? `${userAgentOptions.userAgentPrefix} ${libInfo}`
                : libInfo });
        const authPolicy = coreHttp.isTokenCredential(credential)
            ? challengeBasedAuthenticationPolicy(credential)
            : coreHttp.signingPolicy(credential);
        const internalPipelineOptions = Object.assign(Object.assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                logPolicyOptions: {
                    allowedHeaderNames: [
                        "x-ms-keyvault-region",
                        "x-ms-keyvault-network-info",
                        "x-ms-keyvault-service-version"
                    ]
                }
            }
        });
        const pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new KeyVaultClient(pipelineOptions.serviceVersion || LATEST_API_VERSION, pipeline);
    }
    /**
     * The setSecret method adds a secret or secret version to the Azure Key Vault. If the named secret
     * already exists, Azure Key Vault creates a new version of that secret.
     * This operation requires the secrets/set permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * await client.setSecret("MySecretName", "ABC123");
     * ```
     * @summary Adds a secret in a specified key vault.
     * @param {string} secretName The name of the secret.
     * @param {string} value The value of the secret.
     * @param {SetSecretOptions} [options] The optional parameters.
     */
    setSecret(secretName, value, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            if (requestOptions) {
                const { enabled, notBefore, expiresOn: expires } = requestOptions, remainingOptions = tslib.__rest(requestOptions, ["enabled", "notBefore", "expiresOn"]);
                const unflattenedOptions = Object.assign(Object.assign({}, remainingOptions), { secretAttributes: {
                        enabled,
                        notBefore,
                        expires
                    } });
                const span = this.createSpan("setSecret", unflattenedOptions);
                let response;
                try {
                    response = yield this.client.setSecret(this.vaultUrl, secretName, value, this.setParentSpan(span, unflattenedOptions));
                }
                finally {
                    span.end();
                }
                return this.getSecretFromSecretBundle(response);
            }
            else {
                const response = yield this.client.setSecret(this.vaultUrl, secretName, value, requestOptions);
                return this.getSecretFromSecretBundle(response);
            }
        });
    }
    /**
     * Deletes a secret stored in Azure Key Vault.
     * This function returns a Long Running Operation poller that allows you to wait indefinitely until the secret is deleted.
     *
     * This operation requires the secrets/delete permission.
     *
     * Example usage:
     * ```ts
     * const client = new SecretClient(url, credentials);
     * await client.setSecret("MySecretName", "ABC123");
     *
     * const deletePoller = await client.beginDeleteSecret("MySecretName");
     *
     * // Serializing the poller
     * const serialized = deletePoller.toString();
     *
     * // A new poller can be created with:
     * // const newPoller = await client.beginDeleteSecret("MySecretName", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const deletedSecret = await deletePoller.pollUntilDone();
     * console.log(deletedSecret);
     * ```
     * @summary Deletes a secret from a specified key vault.
     * @param {string} secretName The name of the secret.
     * @param {BeginDeleteSecretOptions} [options] The optional parameters.
     */
    beginDeleteSecret(name, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const poller = new DeleteSecretPoller(Object.assign(Object.assign({ name, client: this.pollerClient }, options), { requestOptions }));
            // This will initialize the poller's operation (the deletion of the secret).
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The updateSecret method changes specified attributes of an existing stored secret. Properties that
     * are not specified in the request are left unchanged. The value of a secret itself cannot be
     * changed. This operation requires the secrets/set permission.
     *
     * Example usage:
     * ```ts
     * let secretName = "MySecretName";
     * let client = new SecretClient(url, credentials);
     * let secret = await client.getSecret(secretName);
     * await client.updateSecretProperties(secretName, secret.properties.version, { enabled: false });
     * ```
     * @summary Updates the attributes associated with a specified secret in a given key vault.
     * @param {string} secretName The name of the secret.
     * @param {string} secretVersion The version of the secret.
     * @param {UpdateSecretPropertiesOptions} [options] The optional parameters.
     */
    updateSecretProperties(secretName, secretVersion, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            if (requestOptions) {
                const { enabled, notBefore, expiresOn: expires } = requestOptions, remainingOptions = tslib.__rest(requestOptions, ["enabled", "notBefore", "expiresOn"]);
                const unflattenedOptions = Object.assign(Object.assign({}, remainingOptions), { secretAttributes: {
                        enabled,
                        notBefore,
                        expires
                    } });
                const span = this.createSpan("updateSecretProperties", unflattenedOptions);
                let response;
                try {
                    response = yield this.client.updateSecret(this.vaultUrl, secretName, secretVersion, this.setParentSpan(span, unflattenedOptions));
                }
                finally {
                    span.end();
                }
                return this.getSecretFromSecretBundle(response).properties;
            }
            else {
                const response = yield this.client.updateSecret(this.vaultUrl, secretName, secretVersion, requestOptions);
                return this.getSecretFromSecretBundle(response).properties;
            }
        });
    }
    /**
     * The getSecret method is applicable to any secret stored in Azure Key Vault. This operation requires
     * the secrets/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * let secret = await client.getSecret("MySecretName");
     * ```
     * @summary Get a specified secret from a given key vault.
     * @param {string} secretName The name of the secret.
     * @param {GetSecretOptions} [options] The optional parameters.
     */
    getSecret(secretName, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("getSecret", requestOptions);
            let response;
            try {
                response = yield this.client.getSecret(this.vaultUrl, secretName, options && options.version ? options.version : "", this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return this.getSecretFromSecretBundle(response);
        });
    }
    /**
     * The getDeletedSecret method returns the specified deleted secret along with its attributes.
     * This operation requires the secrets/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * await client.getDeletedSecret("MyDeletedSecret");
     * ```
     * @summary Gets the specified deleted secret.
     * @param {string} secretName The name of the secret.
     * @param {GetDeletedSecretOptions} [options] The optional parameters.
     */
    getDeletedSecret(secretName, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("getDeletedSecret", requestOptions);
            let response;
            try {
                response = yield this.client.getDeletedSecret(this.vaultUrl, secretName, this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return this.getSecretFromSecretBundle(response);
        });
    }
    /**
     * The purge deleted secret operation removes the secret permanently, without the possibility of
     * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation
     * requires the secrets/purge permission.
     *
     * Example usage:
     * ```ts
     * const client = new SecretClient(url, credentials);
     * const deletePoller = await client.beginDeleteSecret("MySecretName");
     * await deletePoller.pollUntilDone();
     * await client.purgeDeletedSecret("MySecretName");
     * ```
     * @summary Permanently deletes the specified secret.
     * @param {string} secretName The name of the secret.
     * @param {PurgeDeletedSecretOptions} [options] The optional parameters.
     */
    purgeDeletedSecret(secretName, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("purgeDeletedSecret", requestOptions);
            try {
                yield this.client.purgeDeletedSecret(this.vaultUrl, secretName, this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Recovers the deleted secret in the specified vault.
     * This function returns a Long Running Operation poller that allows you to wait indefinitely until the secret is recovered.
     *
     * This operation requires the secrets/recover permission.
     *
     * Example usage:
     * ```ts
     * const client = new SecretClient(url, credentials);
     * await client.setSecret("MySecretName", "ABC123");
     *
     * const deletePoller = await client.beginDeleteSecret("MySecretName");
     * await deletePoller.pollUntilDone();
     *
     * const recoverPoller = await client.beginRecoverDeletedSecret("MySecretName");
     *
     * // Serializing the poller
     * const serialized = recoverPoller.toString();
     *
     * // A new poller can be created with:
     * // const newPoller = await client.beginRecoverDeletedSecret("MySecretName", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const deletedSecret = await recoverPoller.pollUntilDone();
     * console.log(deletedSecret);
     * ```
     * @summary Recovers the deleted secret to the latest version.
     * @param {string} secretName The name of the deleted secret.
     * @param {BeginRecoverDeletedSecretOptions} [options] The optional parameters.
     */
    beginRecoverDeletedSecret(name, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const poller = new RecoverDeletedSecretPoller(Object.assign(Object.assign({ name, client: this.pollerClient }, options), { requestOptions }));
            // This will initialize the poller's operation (the recovery of the deleted secret).
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Requests that a backup of the specified secret be downloaded to the client. All versions of the
     * secret will be downloaded. This operation requires the secrets/backup permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * let backupResult = await client.backupSecret("MySecretName");
     * ```
     * @summary Backs up the specified secret.
     * @param {string} secretName The name of the secret.
     * @param {BackupSecretOptions} [options] The optional parameters.
     */
    backupSecret(secretName, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("backupSecret", requestOptions);
            let response;
            try {
                response = yield this.client.backupSecret(this.vaultUrl, secretName, this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return response.value;
        });
    }
    /**
     * Restores a backed up secret, and all its versions, to a vault. This operation requires the
     * secrets/restore permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * let mySecretBundle = await client.backupSecret("MySecretName");
     * // ...
     * await client.restoreSecretBackup(mySecretBundle);
     * ```
     * @summary Restores a backed up secret to a vault.
     * @param {Uint8Array} secretBundleBackup The backup blob associated with a secret bundle.
     * @param {RestoreSecretResponse} [options] The optional parameters.
     */
    restoreSecretBackup(secretBundleBackup, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("restoreSecretBackup", requestOptions);
            let response;
            try {
                response = yield this.client.restoreSecret(this.vaultUrl, secretBundleBackup, this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return this.getSecretFromSecretBundle(response).properties;
        });
    }
    /**
     * @internal
     * @ignore
     * Sends a delete request for the given KeyVault Secret's name to the KeyVault service.
     * Since the KeyVault Secret won't be immediately deleted, we have {@link beginDeleteSecret}.
     * @param {string} name The name of the KeyVault Secret.
     * @param {RequestOptionsBase} [options] Optional parameters for the underlying HTTP request.
     */
    deleteSecret(secretName, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("deleteSecret", requestOptions);
            let response;
            try {
                response = yield this.client.deleteSecret(this.vaultUrl, secretName, this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return this.getSecretFromSecretBundle(response);
        });
    }
    /**
     * @internal
     * @ignore
     * Sends a request to recover a deleted KeyVault Secret based on the given name.
     * Since the KeyVault Secret won't be immediately recover the deleted secret, we have {@link beginRecoverDeletedSecret}.
     * @param {string} name The name of the KeyVault Secret.
     * @param {RecoverDeletedKeyOptions} [options] Optional parameters for the underlying HTTP request.
     */
    recoverDeletedSecret(secretName, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("recoverDeletedSecret", requestOptions);
            let properties;
            try {
                const response = yield this.client.recoverDeletedSecret(this.vaultUrl, secretName, this.setParentSpan(span, requestOptions));
                properties = this.getSecretFromSecretBundle(response).properties;
            }
            finally {
                span.end();
            }
            return properties;
        });
    }
    /**
     * @internal
     * @ignore
     * Deals with the pagination of {@link listPropertiesOfSecretVersions}.
     * @param {string} name The name of the KeyVault Secret.
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {ListPropertiesOfSecretVersionsOptions} [options] Optional parameters for the underlying HTTP request.
     */
    listPropertiesOfSecretVersionsPage(secretName, continuationState, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listPropertiesOfSecretVersionsPage_1() {
            if (continuationState.continuationToken == null) {
                const optionsComplete = Object.assign({ maxresults: continuationState.maxPageSize }, options);
                const currentSetResponse = yield tslib.__await(this.client.getSecretVersions(this.vaultUrl, secretName, optionsComplete));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map((bundle) => this.getSecretFromSecretBundle(bundle).properties));
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.getSecretVersions(continuationState.continuationToken, secretName, options));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map((bundle) => this.getSecretFromSecretBundle(bundle).properties));
                }
                else {
                    break;
                }
            }
        });
    }
    /**
     * @internal
     * @ignore
     * Deals with the iteration of all the available results of {@link listPropertiesOfSecretVersions}.
     * @param {string} name The name of the KeyVault Secret.
     * @param {ListPropertiesOfSecretVersionsOptions} [options] Optional parameters for the underlying HTTP request.
     */
    listPropertiesOfSecretVersionsAll(secretName, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listPropertiesOfSecretVersionsAll_1() {
            var e_1, _a;
            const f = {};
            try {
                for (var _b = tslib.__asyncValues(this.listPropertiesOfSecretVersionsPage(secretName, f, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const item of page) {
                        yield yield tslib.__await(item);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Iterates all versions of the given secret in the vault. The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * for await (const secretProperties of client.listPropertiesOfSecretVersions("MySecretName")) {
     *   const secret = await client.getSecret(secretProperties.name);
     *   console.log("secret version: ", secret);
     * }
     * ```
     * @param {string} secretName Name of the secret to fetch versions for.
     * @param {ListPropertiesOfSecretVersionsOptions} [options] The optional parameters.
     */
    listPropertiesOfSecretVersions(secretName, options = {}) {
        const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
        const span = this.createSpan("listPropertiesOfSecretVersions", requestOptions);
        const updatedOptions = Object.assign(Object.assign({}, requestOptions), this.setParentSpan(span, requestOptions));
        const iter = this.listPropertiesOfSecretVersionsAll(secretName, updatedOptions);
        span.end();
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listPropertiesOfSecretVersionsPage(secretName, settings, updatedOptions)
        };
    }
    /**
     * @internal
     * @ignore
     * Deals with the pagination of {@link listPropertiesOfSecrets}.
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {ListPropertiesOfSecretsOptions} [options] Optional parameters for the underlying HTTP request.
     */
    listPropertiesOfSecretsPage(continuationState, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listPropertiesOfSecretsPage_1() {
            if (continuationState.continuationToken == null) {
                const optionsComplete = Object.assign({ maxresults: continuationState.maxPageSize }, options);
                const currentSetResponse = yield tslib.__await(this.client.getSecrets(this.vaultUrl, optionsComplete));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map((bundle) => this.getSecretFromSecretBundle(bundle).properties));
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.getSecrets(continuationState.continuationToken, options));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map((bundle) => this.getSecretFromSecretBundle(bundle).properties));
                }
                else {
                    break;
                }
            }
        });
    }
    /**
     * @internal
     * @ignore
     * Deals with the iteration of all the available results of {@link listPropertiesOfSecrets}.
     * @param {ListPropertiesOfSecretsOptions} [options] Optional parameters for the underlying HTTP request.
     */
    listPropertiesOfSecretsAll(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listPropertiesOfSecretsAll_1() {
            var e_2, _a;
            const f = {};
            try {
                for (var _b = tslib.__asyncValues(this.listPropertiesOfSecretsPage(f, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const item of page) {
                        yield yield tslib.__await(item);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Iterates the latest version of all secrets in the vault.  The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * for await (const secretProperties of client.listPropertiesOfSecrets()) {
     *   const secret = await client.getSecret(secretProperties.name);
     *   console.log("secret: ", secret);
     * }
     * ```
     * @summary List all secrets in the vault.
     * @param {ListPropertiesOfSecretsOptions} [options] The optional parameters.
     */
    listPropertiesOfSecrets(options = {}) {
        const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
        const span = this.createSpan("listPropertiesOfSecrets", requestOptions);
        const updatedOptions = Object.assign(Object.assign({}, requestOptions), this.setParentSpan(span, requestOptions));
        const iter = this.listPropertiesOfSecretsAll(updatedOptions);
        span.end();
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listPropertiesOfSecretsPage(settings, updatedOptions)
        };
    }
    /**
     * @internal
     * @ignore
     * Deals with the pagination of {@link listDeletedSecrets}.
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {ListDeletedSecretsOptions} [options] Optional parameters for the underlying HTTP request.
     */
    listDeletedSecretsPage(continuationState, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listDeletedSecretsPage_1() {
            if (continuationState.continuationToken == null) {
                const optionsComplete = Object.assign({ maxresults: continuationState.maxPageSize }, options);
                const currentSetResponse = yield tslib.__await(this.client.getDeletedSecrets(this.vaultUrl, optionsComplete));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map((bundle) => this.getSecretFromSecretBundle(bundle)));
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.getDeletedSecrets(continuationState.continuationToken, options));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map((bundle) => this.getSecretFromSecretBundle(bundle)));
                }
                else {
                    break;
                }
            }
        });
    }
    /**
     * @internal
     * @ignore
     * Deals with the iteration of all the available results of {@link listDeletedSecrets}.
     * @param {ListDeletedSecretsOptions} [options] Optional parameters for the underlying HTTP request.
     */
    listDeletedSecretsAll(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listDeletedSecretsAll_1() {
            var e_3, _a;
            const f = {};
            try {
                for (var _b = tslib.__asyncValues(this.listDeletedSecretsPage(f, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const item of page) {
                        yield yield tslib.__await(item);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Iterates the deleted secrets in the vault.  The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * for await (const deletedSecret of client.listDeletedSecrets()) {
     *   console.log("deleted secret: ", deletedSecret);
     * }
     * ```
     * @summary List all secrets in the vault.
     * @param {ListDeletedSecretsOptions} [options] The optional parameters.
     */
    listDeletedSecrets(options = {}) {
        const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
        const span = this.createSpan("listDeletedSecrets", requestOptions);
        const updatedOptions = Object.assign(Object.assign({}, requestOptions), this.setParentSpan(span, requestOptions));
        const iter = this.listDeletedSecretsAll(updatedOptions);
        span.end();
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listDeletedSecretsPage(settings, updatedOptions)
        };
    }
    /**
     * @internal
     * @ignore
     * Shapes the exposed {@link KeyVaultSecret} based on either a received secret bundle or deleted secret bundle.
     */
    getSecretFromSecretBundle(bundle) {
        const secretBundle = bundle;
        const deletedSecretBundle = bundle;
        const parsedId = parseKeyvaultIdentifier("secrets", secretBundle.id);
        const attributes = secretBundle.attributes;
        delete secretBundle.attributes;
        const resultObject = {
            value: secretBundle.value,
            name: parsedId.name,
            properties: Object.assign(Object.assign(Object.assign({ expiresOn: attributes.expires, createdOn: attributes.created, updatedOn: attributes.updated }, secretBundle), parsedId), attributes)
        };
        if (deletedSecretBundle.deletedDate) {
            resultObject.properties.deletedOn = deletedSecretBundle.deletedDate;
            delete resultObject.properties.deletedDate;
        }
        if (attributes) {
            if (attributes.vaultUrl) {
                delete resultObject.properties.vaultUrl;
            }
            if (attributes.expires) {
                delete resultObject.properties.expires;
            }
            if (attributes.created) {
                delete resultObject.properties.created;
            }
            if (attributes.updated) {
                delete resultObject.properties.updated;
            }
        }
        return resultObject;
    }
    /**
     * @internal
     * @ignore
     * Creates a span using the tracer that was set by the user
     * @param {string} methodName The name of the method creating the span.
     * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.
     */
    createSpan(methodName, requestOptions = {}) {
        const tracer = coreTracing.getTracer();
        const span = tracer.startSpan(methodName, requestOptions && requestOptions.spanOptions);
        span.setAttribute("az.namespace", "Microsoft.KeyVault");
        return span;
    }
    /**
     * @internal
     * @ignore
     * Returns updated HTTP options with the given span as the parent of future spans,
     * if applicable.
     * @param {Span} span The span for the current operation.
     * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.
     */
    setParentSpan(span, options = {}) {
        if (span.isRecording()) {
            const spanOptions = options.spanOptions || {};
            return Object.assign(Object.assign({}, options), { spanOptions: Object.assign(Object.assign({}, spanOptions), { parent: span.context(), attributes: Object.assign(Object.assign({}, spanOptions.attributes), { "az.namespace": "Microsoft.KeyVault" }) }) });
        }
        else {
            return options;
        }
    }
}

exports.SecretClient = SecretClient;
exports.logger = logger;
//# sourceMappingURL=index.js.map
