{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/* eslint @typescript-eslint/member-ordering: 0 */\n/// <reference lib=\"esnext.asynciterable\" />\n\nimport {\n  TokenCredential,\n  isTokenCredential,\n  signingPolicy,\n  RequestOptionsBase,\n  operationOptionsToRequestOptionsBase,\n  PipelineOptions,\n  createPipelineFromOptions\n} from \"@azure/core-http\";\n\nimport { getTracer } from \"@azure/core-tracing\";\nimport { Span } from \"@opentelemetry/api\";\nimport { logger } from \"./log\";\n\nimport \"@azure/core-paging\";\nimport { PageSettings, PagedAsyncIterableIterator } from \"@azure/core-paging\";\nimport { PollerLike, PollOperationState } from \"@azure/core-lro\";\nimport {\n  SecretBundle,\n  DeletedSecretBundle,\n  DeletionRecoveryLevel,\n  KeyVaultClientGetSecretsOptionalParams,\n  SetSecretResponse,\n  DeleteSecretResponse,\n  UpdateSecretResponse,\n  GetSecretResponse,\n  GetDeletedSecretResponse,\n  BackupSecretResponse,\n  RestoreSecretResponse\n} from \"./generated/models\";\nimport { KeyVaultClient } from \"./generated/keyVaultClient\";\nimport { SDK_VERSION } from \"./generated/utils/constants\";\nimport { challengeBasedAuthenticationPolicy } from \"../../keyvault-common/src\";\n\nimport { DeleteSecretPoller } from \"./lro/delete/poller\";\nimport { RecoverDeletedSecretPoller } from \"./lro/recover/poller\";\n\nimport {\n  KeyVaultSecret,\n  DeletedSecret,\n  DeleteSecretOptions,\n  SecretClientInterface,\n  SecretPollerOptions,\n  BeginDeleteSecretOptions,\n  BeginRecoverDeletedSecretOptions,\n  SetSecretOptions,\n  UpdateSecretPropertiesOptions,\n  GetSecretOptions,\n  GetDeletedSecretOptions,\n  PurgeDeletedSecretOptions,\n  BackupSecretOptions,\n  RestoreSecretBackupOptions,\n  RecoverDeletedSecretOptions,\n  ListPropertiesOfSecretVersionsOptions,\n  ListPropertiesOfSecretsOptions,\n  ListDeletedSecretsOptions,\n  SecretProperties,\n  SecretClientOptions,\n  LATEST_API_VERSION\n} from \"./secretsModels\";\nimport { parseKeyvaultIdentifier as parseKeyvaultEntityIdentifier } from \"./generated/utils\";\n\nexport {\n  SecretClientOptions,\n  DeletedSecret,\n  DeletionRecoveryLevel,\n  GetSecretOptions,\n  PipelineOptions,\n  GetDeletedSecretOptions,\n  PurgeDeletedSecretOptions,\n  BackupSecretOptions,\n  RestoreSecretBackupOptions,\n  ListPropertiesOfSecretVersionsOptions,\n  ListPropertiesOfSecretsOptions,\n  ListDeletedSecretsOptions,\n  PagedAsyncIterableIterator,\n  PageSettings,\n  PollerLike,\n  PollOperationState,\n  KeyVaultSecret,\n  SecretProperties,\n  SecretPollerOptions,\n  BeginDeleteSecretOptions,\n  BeginRecoverDeletedSecretOptions,\n  SetSecretOptions,\n  UpdateSecretPropertiesOptions,\n  logger\n};\n\n/**\n * The SecretClient provides methods to manage {@link KeyVaultSecret} in\n * the Azure Key Vault. The client supports creating, retrieving, updating,\n * deleting, purging, backing up, restoring and listing KeyVaultSecrets. The\n * client also supports listing {@link DeletedSecret} for a soft-delete enabled Azure\n * Key Vault.\n */\nexport class SecretClient {\n  /**\n   * The base URL to the vault\n   */\n  public readonly vaultUrl: string;\n\n  /**\n   * @internal\n   * @ignore\n   * A reference to the auto-generated KeyVault HTTP client.\n   */\n  private readonly client: KeyVaultClient;\n\n  /**\n   * @internal\n   * @ignore\n   * A self reference that bypasses private methods, for the pollers.\n   */\n  private readonly pollerClient: SecretClientInterface = {\n    recoverDeletedSecret: this.recoverDeletedSecret.bind(this),\n    getSecret: this.getSecret.bind(this),\n    deleteSecret: this.deleteSecret.bind(this),\n    getDeletedSecret: this.getDeletedSecret.bind(this)\n  };\n\n  /**\n   * Creates an instance of SecretClient.\n   *\n   * Example usage:\n   * ```ts\n   * import { SecretClient } from \"@azure/keyvault-secrets\";\n   * import { DefaultAzureCredential } from \"@azure/identity\";\n   *\n   * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;\n   * let credentials = new DefaultAzureCredential();\n   *\n   * let client = new SecretClient(vaultUrl, credentials);\n   * ```\n   * @param {string} vaultUrl the base URL to the vault.\n   * @param {TokenCredential} credential An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the @azure/identity package to create a credential that suits your needs.\n   * @param {PipelineOptions} [pipelineOptions] Optional. Pipeline options used to configure Key Vault API requests.\n   *                                                         Omit this parameter to use the default pipeline configuration.\n   * @memberof SecretClient\n   */\n  constructor(\n    vaultUrl: string,\n    credential: TokenCredential,\n    pipelineOptions: SecretClientOptions = {}\n  ) {\n    this.vaultUrl = vaultUrl;\n\n    const libInfo = `azsdk-js-keyvault-secrets/${SDK_VERSION}`;\n\n    const userAgentOptions = pipelineOptions.userAgentOptions;\n\n    pipelineOptions.userAgentOptions = {\n      ...pipelineOptions.userAgentOptions,\n      userAgentPrefix:\n        userAgentOptions && userAgentOptions.userAgentPrefix\n          ? `${userAgentOptions.userAgentPrefix} ${libInfo}`\n          : libInfo\n    };\n\n    const authPolicy = isTokenCredential(credential)\n      ? challengeBasedAuthenticationPolicy(credential)\n      : signingPolicy(credential);\n\n    const internalPipelineOptions = {\n      ...pipelineOptions,\n      ...{\n        loggingOptions: {\n          logger: logger.info,\n          logPolicyOptions: {\n            allowedHeaderNames: [\n              \"x-ms-keyvault-region\",\n              \"x-ms-keyvault-network-info\",\n              \"x-ms-keyvault-service-version\"\n            ]\n          }\n        }\n      }\n    };\n\n    const pipeline = createPipelineFromOptions(internalPipelineOptions, authPolicy);\n    this.client = new KeyVaultClient(\n      pipelineOptions.serviceVersion || LATEST_API_VERSION,\n      pipeline\n    );\n  }\n\n  /**\n   * The setSecret method adds a secret or secret version to the Azure Key Vault. If the named secret\n   * already exists, Azure Key Vault creates a new version of that secret.\n   * This operation requires the secrets/set permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * await client.setSecret(\"MySecretName\", \"ABC123\");\n   * ```\n   * @summary Adds a secret in a specified key vault.\n   * @param {string} secretName The name of the secret.\n   * @param {string} value The value of the secret.\n   * @param {SetSecretOptions} [options] The optional parameters.\n   */\n  public async setSecret(\n    secretName: string,\n    value: string,\n    options: SetSecretOptions = {}\n  ): Promise<KeyVaultSecret> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n\n    if (requestOptions) {\n      const { enabled, notBefore, expiresOn: expires, ...remainingOptions } = requestOptions;\n      const unflattenedOptions = {\n        ...remainingOptions,\n        secretAttributes: {\n          enabled,\n          notBefore,\n          expires\n        }\n      };\n\n      const span = this.createSpan(\"setSecret\", unflattenedOptions);\n\n      let response: SetSecretResponse;\n      try {\n        response = await this.client.setSecret(\n          this.vaultUrl,\n          secretName,\n          value,\n          this.setParentSpan(span, unflattenedOptions)\n        );\n      } finally {\n        span.end();\n      }\n\n      return this.getSecretFromSecretBundle(response);\n    } else {\n      const response = await this.client.setSecret(\n        this.vaultUrl,\n        secretName,\n        value,\n        requestOptions\n      );\n      return this.getSecretFromSecretBundle(response);\n    }\n  }\n\n  /**\n   * Deletes a secret stored in Azure Key Vault.\n   * This function returns a Long Running Operation poller that allows you to wait indefinitely until the secret is deleted.\n   *\n   * This operation requires the secrets/delete permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new SecretClient(url, credentials);\n   * await client.setSecret(\"MySecretName\", \"ABC123\");\n   *\n   * const deletePoller = await client.beginDeleteSecret(\"MySecretName\");\n   *\n   * // Serializing the poller\n   * const serialized = deletePoller.toString();\n   *\n   * // A new poller can be created with:\n   * // const newPoller = await client.beginDeleteSecret(\"MySecretName\", { resumeFrom: serialized });\n   *\n   * // Waiting until it's done\n   * const deletedSecret = await deletePoller.pollUntilDone();\n   * console.log(deletedSecret);\n   * ```\n   * @summary Deletes a secret from a specified key vault.\n   * @param {string} secretName The name of the secret.\n   * @param {BeginDeleteSecretOptions} [options] The optional parameters.\n   */\n  public async beginDeleteSecret(\n    name: string,\n    options: BeginDeleteSecretOptions = {}\n  ): Promise<PollerLike<PollOperationState<DeletedSecret>, DeletedSecret>> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const poller = new DeleteSecretPoller({\n      name,\n      client: this.pollerClient,\n      ...options,\n      requestOptions\n    });\n    // This will initialize the poller's operation (the deletion of the secret).\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * The updateSecret method changes specified attributes of an existing stored secret. Properties that\n   * are not specified in the request are left unchanged. The value of a secret itself cannot be\n   * changed. This operation requires the secrets/set permission.\n   *\n   * Example usage:\n   * ```ts\n   * let secretName = \"MySecretName\";\n   * let client = new SecretClient(url, credentials);\n   * let secret = await client.getSecret(secretName);\n   * await client.updateSecretProperties(secretName, secret.properties.version, { enabled: false });\n   * ```\n   * @summary Updates the attributes associated with a specified secret in a given key vault.\n   * @param {string} secretName The name of the secret.\n   * @param {string} secretVersion The version of the secret.\n   * @param {UpdateSecretPropertiesOptions} [options] The optional parameters.\n   */\n  public async updateSecretProperties(\n    secretName: string,\n    secretVersion: string,\n    options: UpdateSecretPropertiesOptions = {}\n  ): Promise<SecretProperties> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n\n    if (requestOptions) {\n      const { enabled, notBefore, expiresOn: expires, ...remainingOptions } = requestOptions;\n      const unflattenedOptions = {\n        ...remainingOptions,\n        secretAttributes: {\n          enabled,\n          notBefore,\n          expires\n        }\n      };\n\n      const span = this.createSpan(\"updateSecretProperties\", unflattenedOptions);\n\n      let response: UpdateSecretResponse;\n\n      try {\n        response = await this.client.updateSecret(\n          this.vaultUrl,\n          secretName,\n          secretVersion,\n          this.setParentSpan(span, unflattenedOptions)\n        );\n      } finally {\n        span.end();\n      }\n\n      return this.getSecretFromSecretBundle(response).properties;\n    } else {\n      const response = await this.client.updateSecret(\n        this.vaultUrl,\n        secretName,\n        secretVersion,\n        requestOptions\n      );\n      return this.getSecretFromSecretBundle(response).properties;\n    }\n  }\n\n  /**\n   * The getSecret method is applicable to any secret stored in Azure Key Vault. This operation requires\n   * the secrets/get permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * let secret = await client.getSecret(\"MySecretName\");\n   * ```\n   * @summary Get a specified secret from a given key vault.\n   * @param {string} secretName The name of the secret.\n   * @param {GetSecretOptions} [options] The optional parameters.\n   */\n  public async getSecret(\n    secretName: string,\n    options: GetSecretOptions = {}\n  ): Promise<KeyVaultSecret> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"getSecret\", requestOptions);\n\n    let response: GetSecretResponse;\n    try {\n      response = await this.client.getSecret(\n        this.vaultUrl,\n        secretName,\n        options && options.version ? options.version : \"\",\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return this.getSecretFromSecretBundle(response);\n  }\n\n  /**\n   * The getDeletedSecret method returns the specified deleted secret along with its attributes.\n   * This operation requires the secrets/get permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * await client.getDeletedSecret(\"MyDeletedSecret\");\n   * ```\n   * @summary Gets the specified deleted secret.\n   * @param {string} secretName The name of the secret.\n   * @param {GetDeletedSecretOptions} [options] The optional parameters.\n   */\n  public async getDeletedSecret(\n    secretName: string,\n    options: GetDeletedSecretOptions = {}\n  ): Promise<DeletedSecret> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"getDeletedSecret\", requestOptions);\n\n    let response: GetDeletedSecretResponse;\n\n    try {\n      response = await this.client.getDeletedSecret(\n        this.vaultUrl,\n        secretName,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return this.getSecretFromSecretBundle(response);\n  }\n\n  /**\n   * The purge deleted secret operation removes the secret permanently, without the possibility of\n   * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation\n   * requires the secrets/purge permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new SecretClient(url, credentials);\n   * const deletePoller = await client.beginDeleteSecret(\"MySecretName\");\n   * await deletePoller.pollUntilDone();\n   * await client.purgeDeletedSecret(\"MySecretName\");\n   * ```\n   * @summary Permanently deletes the specified secret.\n   * @param {string} secretName The name of the secret.\n   * @param {PurgeDeletedSecretOptions} [options] The optional parameters.\n   */\n  public async purgeDeletedSecret(\n    secretName: string,\n    options: PurgeDeletedSecretOptions = {}\n  ): Promise<void> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"purgeDeletedSecret\", requestOptions);\n\n    try {\n      await this.client.purgeDeletedSecret(\n        this.vaultUrl,\n        secretName,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Recovers the deleted secret in the specified vault.\n   * This function returns a Long Running Operation poller that allows you to wait indefinitely until the secret is recovered.\n   *\n   * This operation requires the secrets/recover permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new SecretClient(url, credentials);\n   * await client.setSecret(\"MySecretName\", \"ABC123\");\n   *\n   * const deletePoller = await client.beginDeleteSecret(\"MySecretName\");\n   * await deletePoller.pollUntilDone();\n   *\n   * const recoverPoller = await client.beginRecoverDeletedSecret(\"MySecretName\");\n   *\n   * // Serializing the poller\n   * const serialized = recoverPoller.toString();\n   *\n   * // A new poller can be created with:\n   * // const newPoller = await client.beginRecoverDeletedSecret(\"MySecretName\", { resumeFrom: serialized });\n   *\n   * // Waiting until it's done\n   * const deletedSecret = await recoverPoller.pollUntilDone();\n   * console.log(deletedSecret);\n   * ```\n   * @summary Recovers the deleted secret to the latest version.\n   * @param {string} secretName The name of the deleted secret.\n   * @param {BeginRecoverDeletedSecretOptions} [options] The optional parameters.\n   */\n  public async beginRecoverDeletedSecret(\n    name: string,\n    options: BeginRecoverDeletedSecretOptions = {}\n  ): Promise<PollerLike<PollOperationState<SecretProperties>, SecretProperties>> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n\n    const poller = new RecoverDeletedSecretPoller({\n      name,\n      client: this.pollerClient,\n      ...options,\n      requestOptions\n    });\n\n    // This will initialize the poller's operation (the recovery of the deleted secret).\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Requests that a backup of the specified secret be downloaded to the client. All versions of the\n   * secret will be downloaded. This operation requires the secrets/backup permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * let backupResult = await client.backupSecret(\"MySecretName\");\n   * ```\n   * @summary Backs up the specified secret.\n   * @param {string} secretName The name of the secret.\n   * @param {BackupSecretOptions} [options] The optional parameters.\n   */\n  public async backupSecret(\n    secretName: string,\n    options: BackupSecretOptions = {}\n  ): Promise<Uint8Array | undefined> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"backupSecret\", requestOptions);\n\n    let response: BackupSecretResponse;\n\n    try {\n      response = await this.client.backupSecret(\n        this.vaultUrl,\n        secretName,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n    return response.value;\n  }\n\n  /**\n   * Restores a backed up secret, and all its versions, to a vault. This operation requires the\n   * secrets/restore permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * let mySecretBundle = await client.backupSecret(\"MySecretName\");\n   * // ...\n   * await client.restoreSecretBackup(mySecretBundle);\n   * ```\n   * @summary Restores a backed up secret to a vault.\n   * @param {Uint8Array} secretBundleBackup The backup blob associated with a secret bundle.\n   * @param {RestoreSecretResponse} [options] The optional parameters.\n   */\n  public async restoreSecretBackup(\n    secretBundleBackup: Uint8Array,\n    options: RestoreSecretBackupOptions = {}\n  ): Promise<SecretProperties> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"restoreSecretBackup\", requestOptions);\n\n    let response: RestoreSecretResponse;\n\n    try {\n      response = await this.client.restoreSecret(\n        this.vaultUrl,\n        secretBundleBackup,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return this.getSecretFromSecretBundle(response).properties;\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Sends a delete request for the given KeyVault Secret's name to the KeyVault service.\n   * Since the KeyVault Secret won't be immediately deleted, we have {@link beginDeleteSecret}.\n   * @param {string} name The name of the KeyVault Secret.\n   * @param {RequestOptionsBase} [options] Optional parameters for the underlying HTTP request.\n   */\n  private async deleteSecret(\n    secretName: string,\n    options: DeleteSecretOptions = {}\n  ): Promise<DeletedSecret> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"deleteSecret\", requestOptions);\n\n    let response: DeleteSecretResponse;\n    try {\n      response = await this.client.deleteSecret(\n        this.vaultUrl,\n        secretName,\n        this.setParentSpan(span, requestOptions)\n      );\n    } finally {\n      span.end();\n    }\n\n    return this.getSecretFromSecretBundle(response);\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Sends a request to recover a deleted KeyVault Secret based on the given name.\n   * Since the KeyVault Secret won't be immediately recover the deleted secret, we have {@link beginRecoverDeletedSecret}.\n   * @param {string} name The name of the KeyVault Secret.\n   * @param {RecoverDeletedKeyOptions} [options] Optional parameters for the underlying HTTP request.\n   */\n  private async recoverDeletedSecret(\n    secretName: string,\n    options: RecoverDeletedSecretOptions = {}\n  ): Promise<SecretProperties> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"recoverDeletedSecret\", requestOptions);\n\n    let properties: SecretProperties;\n\n    try {\n      const response = await this.client.recoverDeletedSecret(\n        this.vaultUrl,\n        secretName,\n        this.setParentSpan(span, requestOptions)\n      );\n      properties = this.getSecretFromSecretBundle(response).properties;\n    } finally {\n      span.end();\n    }\n\n    return properties;\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the pagination of {@link listPropertiesOfSecretVersions}.\n   * @param {string} name The name of the KeyVault Secret.\n   * @param {PageSettings} continuationState An object that indicates the position of the paginated request.\n   * @param {ListPropertiesOfSecretVersionsOptions} [options] Optional parameters for the underlying HTTP request.\n   */\n  private async *listPropertiesOfSecretVersionsPage(\n    secretName: string,\n    continuationState: PageSettings,\n    options: ListPropertiesOfSecretVersionsOptions = {}\n  ): AsyncIterableIterator<SecretProperties[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: KeyVaultClientGetSecretsOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options\n      };\n      const currentSetResponse = await this.client.getSecretVersions(\n        this.vaultUrl,\n        secretName,\n        optionsComplete\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(\n          (bundle) => this.getSecretFromSecretBundle(bundle).properties\n        );\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await this.client.getSecretVersions(\n        continuationState.continuationToken,\n        secretName,\n        options\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(\n          (bundle) => this.getSecretFromSecretBundle(bundle).properties\n        );\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the iteration of all the available results of {@link listPropertiesOfSecretVersions}.\n   * @param {string} name The name of the KeyVault Secret.\n   * @param {ListPropertiesOfSecretVersionsOptions} [options] Optional parameters for the underlying HTTP request.\n   */\n  private async *listPropertiesOfSecretVersionsAll(\n    secretName: string,\n    options: ListPropertiesOfSecretVersionsOptions = {}\n  ): AsyncIterableIterator<SecretProperties> {\n    const f = {};\n\n    for await (const page of this.listPropertiesOfSecretVersionsPage(secretName, f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates all versions of the given secret in the vault. The full secret identifier and attributes are provided\n   * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * for await (const secretProperties of client.listPropertiesOfSecretVersions(\"MySecretName\")) {\n   *   const secret = await client.getSecret(secretProperties.name);\n   *   console.log(\"secret version: \", secret);\n   * }\n   * ```\n   * @param {string} secretName Name of the secret to fetch versions for.\n   * @param {ListPropertiesOfSecretVersionsOptions} [options] The optional parameters.\n   */\n  public listPropertiesOfSecretVersions(\n    secretName: string,\n    options: ListPropertiesOfSecretVersionsOptions = {}\n  ): PagedAsyncIterableIterator<SecretProperties> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"listPropertiesOfSecretVersions\", requestOptions);\n    const updatedOptions: ListPropertiesOfSecretVersionsOptions = {\n      ...requestOptions,\n      ...this.setParentSpan(span, requestOptions)\n    };\n\n    const iter = this.listPropertiesOfSecretVersionsAll(secretName, updatedOptions);\n\n    span.end();\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) =>\n        this.listPropertiesOfSecretVersionsPage(secretName, settings, updatedOptions)\n    };\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the pagination of {@link listPropertiesOfSecrets}.\n   * @param {PageSettings} continuationState An object that indicates the position of the paginated request.\n   * @param {ListPropertiesOfSecretsOptions} [options] Optional parameters for the underlying HTTP request.\n   */\n  private async *listPropertiesOfSecretsPage(\n    continuationState: PageSettings,\n    options: ListPropertiesOfSecretsOptions = {}\n  ): AsyncIterableIterator<SecretProperties[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: KeyVaultClientGetSecretsOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options\n      };\n      const currentSetResponse = await this.client.getSecrets(this.vaultUrl, optionsComplete);\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(\n          (bundle) => this.getSecretFromSecretBundle(bundle).properties\n        );\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await this.client.getSecrets(\n        continuationState.continuationToken,\n        options\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(\n          (bundle) => this.getSecretFromSecretBundle(bundle).properties\n        );\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the iteration of all the available results of {@link listPropertiesOfSecrets}.\n   * @param {ListPropertiesOfSecretsOptions} [options] Optional parameters for the underlying HTTP request.\n   */\n  private async *listPropertiesOfSecretsAll(\n    options: ListPropertiesOfSecretsOptions = {}\n  ): AsyncIterableIterator<SecretProperties> {\n    const f = {};\n\n    for await (const page of this.listPropertiesOfSecretsPage(f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates the latest version of all secrets in the vault.  The full secret identifier and attributes are provided\n   * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * for await (const secretProperties of client.listPropertiesOfSecrets()) {\n   *   const secret = await client.getSecret(secretProperties.name);\n   *   console.log(\"secret: \", secret);\n   * }\n   * ```\n   * @summary List all secrets in the vault.\n   * @param {ListPropertiesOfSecretsOptions} [options] The optional parameters.\n   */\n  public listPropertiesOfSecrets(\n    options: ListPropertiesOfSecretsOptions = {}\n  ): PagedAsyncIterableIterator<SecretProperties> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"listPropertiesOfSecrets\", requestOptions);\n    const updatedOptions: ListPropertiesOfSecretsOptions = {\n      ...requestOptions,\n      ...this.setParentSpan(span, requestOptions)\n    };\n\n    const iter = this.listPropertiesOfSecretsAll(updatedOptions);\n\n    span.end();\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) =>\n        this.listPropertiesOfSecretsPage(settings, updatedOptions)\n    };\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the pagination of {@link listDeletedSecrets}.\n   * @param {PageSettings} continuationState An object that indicates the position of the paginated request.\n   * @param {ListDeletedSecretsOptions} [options] Optional parameters for the underlying HTTP request.\n   */\n  private async *listDeletedSecretsPage(\n    continuationState: PageSettings,\n    options: ListDeletedSecretsOptions = {}\n  ): AsyncIterableIterator<DeletedSecret[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: KeyVaultClientGetSecretsOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options\n      };\n      const currentSetResponse = await this.client.getDeletedSecrets(\n        this.vaultUrl,\n        optionsComplete\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map((bundle) => this.getSecretFromSecretBundle(bundle));\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await this.client.getDeletedSecrets(\n        continuationState.continuationToken,\n        options\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map((bundle) => this.getSecretFromSecretBundle(bundle));\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Deals with the iteration of all the available results of {@link listDeletedSecrets}.\n   * @param {ListDeletedSecretsOptions} [options] Optional parameters for the underlying HTTP request.\n   */\n  private async *listDeletedSecretsAll(\n    options: ListDeletedSecretsOptions = {}\n  ): AsyncIterableIterator<DeletedSecret> {\n    const f = {};\n\n    for await (const page of this.listDeletedSecretsPage(f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates the deleted secrets in the vault.  The full secret identifier and attributes are provided\n   * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * for await (const deletedSecret of client.listDeletedSecrets()) {\n   *   console.log(\"deleted secret: \", deletedSecret);\n   * }\n   * ```\n   * @summary List all secrets in the vault.\n   * @param {ListDeletedSecretsOptions} [options] The optional parameters.\n   */\n  public listDeletedSecrets(\n    options: ListDeletedSecretsOptions = {}\n  ): PagedAsyncIterableIterator<DeletedSecret> {\n    const requestOptions = operationOptionsToRequestOptionsBase(options);\n    const span = this.createSpan(\"listDeletedSecrets\", requestOptions);\n    const updatedOptions: ListDeletedSecretsOptions = {\n      ...requestOptions,\n      ...this.setParentSpan(span, requestOptions)\n    };\n\n    const iter = this.listDeletedSecretsAll(updatedOptions);\n\n    span.end();\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) => this.listDeletedSecretsPage(settings, updatedOptions)\n    };\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Shapes the exposed {@link KeyVaultSecret} based on either a received secret bundle or deleted secret bundle.\n   */\n  private getSecretFromSecretBundle(bundle: SecretBundle | DeletedSecretBundle): KeyVaultSecret {\n    const secretBundle = bundle as SecretBundle;\n    const deletedSecretBundle = bundle as DeletedSecretBundle;\n    const parsedId = parseKeyvaultEntityIdentifier(\"secrets\", secretBundle.id);\n\n    const attributes = secretBundle.attributes;\n    delete secretBundle.attributes;\n\n    const resultObject: KeyVaultSecret & DeletedSecret = {\n      value: secretBundle.value,\n      name: parsedId.name,\n      properties: {\n        expiresOn: (attributes as any).expires,\n        createdOn: (attributes as any).created,\n        updatedOn: (attributes as any).updated,\n        ...secretBundle,\n        ...parsedId,\n        ...attributes\n      }\n    };\n\n    if (deletedSecretBundle.deletedDate) {\n      resultObject.properties.deletedOn = deletedSecretBundle.deletedDate;\n      delete (resultObject.properties as any).deletedDate;\n    }\n\n    if (attributes) {\n      if ((attributes as any).vaultUrl) {\n        delete (resultObject.properties as any).vaultUrl;\n      }\n\n      if (attributes.expires) {\n        delete (resultObject.properties as any).expires;\n      }\n\n      if (attributes.created) {\n        delete (resultObject.properties as any).created;\n      }\n\n      if (attributes.updated) {\n        delete (resultObject.properties as any).updated;\n      }\n    }\n\n    return resultObject;\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Creates a span using the tracer that was set by the user\n   * @param {string} methodName The name of the method creating the span.\n   * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.\n   */\n  private createSpan(methodName: string, requestOptions: RequestOptionsBase = {}): Span {\n    const tracer = getTracer();\n    const span = tracer.startSpan(methodName, requestOptions && requestOptions.spanOptions);\n    span.setAttribute(\"az.namespace\", \"Microsoft.KeyVault\");\n    return span;\n  }\n\n  /**\n   * @internal\n   * @ignore\n   * Returns updated HTTP options with the given span as the parent of future spans,\n   * if applicable.\n   * @param {Span} span The span for the current operation.\n   * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.\n   */\n  private setParentSpan(span: Span, options: RequestOptionsBase = {}): RequestOptionsBase {\n    if (span.isRecording()) {\n      const spanOptions = options.spanOptions || {};\n      return {\n        ...options,\n        spanOptions: {\n          ...spanOptions,\n          parent: span.context(),\n          attributes: {\n            ...spanOptions.attributes,\n            \"az.namespace\": \"Microsoft.KeyVault\"\n          }\n        }\n      };\n    } else {\n      return options;\n    }\n  }\n}\n"]}