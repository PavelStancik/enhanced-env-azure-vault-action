// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/* eslint @typescript-eslint/member-ordering: 0 */
/// <reference lib="esnext.asynciterable" />
import { __asyncGenerator, __asyncValues, __await, __awaiter, __rest } from "tslib";
import { isTokenCredential, signingPolicy, operationOptionsToRequestOptionsBase, createPipelineFromOptions } from "@azure/core-http";
import { getTracer } from "@azure/core-tracing";
import { logger } from "./log";
import "@azure/core-paging";
import { KeyVaultClient } from "./generated/keyVaultClient";
import { SDK_VERSION } from "./generated/utils/constants";
import { challengeBasedAuthenticationPolicy } from "../../keyvault-common/src";
import { DeleteSecretPoller } from "./lro/delete/poller";
import { RecoverDeletedSecretPoller } from "./lro/recover/poller";
import { LATEST_API_VERSION } from "./secretsModels";
import { parseKeyvaultIdentifier as parseKeyvaultEntityIdentifier } from "./generated/utils";
export { logger };
/**
 * The SecretClient provides methods to manage {@link KeyVaultSecret} in
 * the Azure Key Vault. The client supports creating, retrieving, updating,
 * deleting, purging, backing up, restoring and listing KeyVaultSecrets. The
 * client also supports listing {@link DeletedSecret} for a soft-delete enabled Azure
 * Key Vault.
 */
export class SecretClient {
    /**
     * Creates an instance of SecretClient.
     *
     * Example usage:
     * ```ts
     * import { SecretClient } from "@azure/keyvault-secrets";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;
     * let credentials = new DefaultAzureCredential();
     *
     * let client = new SecretClient(vaultUrl, credentials);
     * ```
     * @param {string} vaultUrl the base URL to the vault.
     * @param {TokenCredential} credential An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the @azure/identity package to create a credential that suits your needs.
     * @param {PipelineOptions} [pipelineOptions] Optional. Pipeline options used to configure Key Vault API requests.
     *                                                         Omit this parameter to use the default pipeline configuration.
     * @memberof SecretClient
     */
    constructor(vaultUrl, credential, pipelineOptions = {}) {
        /**
         * @internal
         * @ignore
         * A self reference that bypasses private methods, for the pollers.
         */
        this.pollerClient = {
            recoverDeletedSecret: this.recoverDeletedSecret.bind(this),
            getSecret: this.getSecret.bind(this),
            deleteSecret: this.deleteSecret.bind(this),
            getDeletedSecret: this.getDeletedSecret.bind(this)
        };
        this.vaultUrl = vaultUrl;
        const libInfo = `azsdk-js-keyvault-secrets/${SDK_VERSION}`;
        const userAgentOptions = pipelineOptions.userAgentOptions;
        pipelineOptions.userAgentOptions = Object.assign(Object.assign({}, pipelineOptions.userAgentOptions), { userAgentPrefix: userAgentOptions && userAgentOptions.userAgentPrefix
                ? `${userAgentOptions.userAgentPrefix} ${libInfo}`
                : libInfo });
        const authPolicy = isTokenCredential(credential)
            ? challengeBasedAuthenticationPolicy(credential)
            : signingPolicy(credential);
        const internalPipelineOptions = Object.assign(Object.assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                logPolicyOptions: {
                    allowedHeaderNames: [
                        "x-ms-keyvault-region",
                        "x-ms-keyvault-network-info",
                        "x-ms-keyvault-service-version"
                    ]
                }
            }
        });
        const pipeline = createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new KeyVaultClient(pipelineOptions.serviceVersion || LATEST_API_VERSION, pipeline);
    }
    /**
     * The setSecret method adds a secret or secret version to the Azure Key Vault. If the named secret
     * already exists, Azure Key Vault creates a new version of that secret.
     * This operation requires the secrets/set permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * await client.setSecret("MySecretName", "ABC123");
     * ```
     * @summary Adds a secret in a specified key vault.
     * @param {string} secretName The name of the secret.
     * @param {string} value The value of the secret.
     * @param {SetSecretOptions} [options] The optional parameters.
     */
    setSecret(secretName, value, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestOptions = operationOptionsToRequestOptionsBase(options);
            if (requestOptions) {
                const { enabled, notBefore, expiresOn: expires } = requestOptions, remainingOptions = __rest(requestOptions, ["enabled", "notBefore", "expiresOn"]);
                const unflattenedOptions = Object.assign(Object.assign({}, remainingOptions), { secretAttributes: {
                        enabled,
                        notBefore,
                        expires
                    } });
                const span = this.createSpan("setSecret", unflattenedOptions);
                let response;
                try {
                    response = yield this.client.setSecret(this.vaultUrl, secretName, value, this.setParentSpan(span, unflattenedOptions));
                }
                finally {
                    span.end();
                }
                return this.getSecretFromSecretBundle(response);
            }
            else {
                const response = yield this.client.setSecret(this.vaultUrl, secretName, value, requestOptions);
                return this.getSecretFromSecretBundle(response);
            }
        });
    }
    /**
     * Deletes a secret stored in Azure Key Vault.
     * This function returns a Long Running Operation poller that allows you to wait indefinitely until the secret is deleted.
     *
     * This operation requires the secrets/delete permission.
     *
     * Example usage:
     * ```ts
     * const client = new SecretClient(url, credentials);
     * await client.setSecret("MySecretName", "ABC123");
     *
     * const deletePoller = await client.beginDeleteSecret("MySecretName");
     *
     * // Serializing the poller
     * const serialized = deletePoller.toString();
     *
     * // A new poller can be created with:
     * // const newPoller = await client.beginDeleteSecret("MySecretName", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const deletedSecret = await deletePoller.pollUntilDone();
     * console.log(deletedSecret);
     * ```
     * @summary Deletes a secret from a specified key vault.
     * @param {string} secretName The name of the secret.
     * @param {BeginDeleteSecretOptions} [options] The optional parameters.
     */
    beginDeleteSecret(name, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestOptions = operationOptionsToRequestOptionsBase(options);
            const poller = new DeleteSecretPoller(Object.assign(Object.assign({ name, client: this.pollerClient }, options), { requestOptions }));
            // This will initialize the poller's operation (the deletion of the secret).
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The updateSecret method changes specified attributes of an existing stored secret. Properties that
     * are not specified in the request are left unchanged. The value of a secret itself cannot be
     * changed. This operation requires the secrets/set permission.
     *
     * Example usage:
     * ```ts
     * let secretName = "MySecretName";
     * let client = new SecretClient(url, credentials);
     * let secret = await client.getSecret(secretName);
     * await client.updateSecretProperties(secretName, secret.properties.version, { enabled: false });
     * ```
     * @summary Updates the attributes associated with a specified secret in a given key vault.
     * @param {string} secretName The name of the secret.
     * @param {string} secretVersion The version of the secret.
     * @param {UpdateSecretPropertiesOptions} [options] The optional parameters.
     */
    updateSecretProperties(secretName, secretVersion, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestOptions = operationOptionsToRequestOptionsBase(options);
            if (requestOptions) {
                const { enabled, notBefore, expiresOn: expires } = requestOptions, remainingOptions = __rest(requestOptions, ["enabled", "notBefore", "expiresOn"]);
                const unflattenedOptions = Object.assign(Object.assign({}, remainingOptions), { secretAttributes: {
                        enabled,
                        notBefore,
                        expires
                    } });
                const span = this.createSpan("updateSecretProperties", unflattenedOptions);
                let response;
                try {
                    response = yield this.client.updateSecret(this.vaultUrl, secretName, secretVersion, this.setParentSpan(span, unflattenedOptions));
                }
                finally {
                    span.end();
                }
                return this.getSecretFromSecretBundle(response).properties;
            }
            else {
                const response = yield this.client.updateSecret(this.vaultUrl, secretName, secretVersion, requestOptions);
                return this.getSecretFromSecretBundle(response).properties;
            }
        });
    }
    /**
     * The getSecret method is applicable to any secret stored in Azure Key Vault. This operation requires
     * the secrets/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * let secret = await client.getSecret("MySecretName");
     * ```
     * @summary Get a specified secret from a given key vault.
     * @param {string} secretName The name of the secret.
     * @param {GetSecretOptions} [options] The optional parameters.
     */
    getSecret(secretName, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestOptions = operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("getSecret", requestOptions);
            let response;
            try {
                response = yield this.client.getSecret(this.vaultUrl, secretName, options && options.version ? options.version : "", this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return this.getSecretFromSecretBundle(response);
        });
    }
    /**
     * The getDeletedSecret method returns the specified deleted secret along with its attributes.
     * This operation requires the secrets/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * await client.getDeletedSecret("MyDeletedSecret");
     * ```
     * @summary Gets the specified deleted secret.
     * @param {string} secretName The name of the secret.
     * @param {GetDeletedSecretOptions} [options] The optional parameters.
     */
    getDeletedSecret(secretName, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestOptions = operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("getDeletedSecret", requestOptions);
            let response;
            try {
                response = yield this.client.getDeletedSecret(this.vaultUrl, secretName, this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return this.getSecretFromSecretBundle(response);
        });
    }
    /**
     * The purge deleted secret operation removes the secret permanently, without the possibility of
     * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation
     * requires the secrets/purge permission.
     *
     * Example usage:
     * ```ts
     * const client = new SecretClient(url, credentials);
     * const deletePoller = await client.beginDeleteSecret("MySecretName");
     * await deletePoller.pollUntilDone();
     * await client.purgeDeletedSecret("MySecretName");
     * ```
     * @summary Permanently deletes the specified secret.
     * @param {string} secretName The name of the secret.
     * @param {PurgeDeletedSecretOptions} [options] The optional parameters.
     */
    purgeDeletedSecret(secretName, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestOptions = operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("purgeDeletedSecret", requestOptions);
            try {
                yield this.client.purgeDeletedSecret(this.vaultUrl, secretName, this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Recovers the deleted secret in the specified vault.
     * This function returns a Long Running Operation poller that allows you to wait indefinitely until the secret is recovered.
     *
     * This operation requires the secrets/recover permission.
     *
     * Example usage:
     * ```ts
     * const client = new SecretClient(url, credentials);
     * await client.setSecret("MySecretName", "ABC123");
     *
     * const deletePoller = await client.beginDeleteSecret("MySecretName");
     * await deletePoller.pollUntilDone();
     *
     * const recoverPoller = await client.beginRecoverDeletedSecret("MySecretName");
     *
     * // Serializing the poller
     * const serialized = recoverPoller.toString();
     *
     * // A new poller can be created with:
     * // const newPoller = await client.beginRecoverDeletedSecret("MySecretName", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const deletedSecret = await recoverPoller.pollUntilDone();
     * console.log(deletedSecret);
     * ```
     * @summary Recovers the deleted secret to the latest version.
     * @param {string} secretName The name of the deleted secret.
     * @param {BeginRecoverDeletedSecretOptions} [options] The optional parameters.
     */
    beginRecoverDeletedSecret(name, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestOptions = operationOptionsToRequestOptionsBase(options);
            const poller = new RecoverDeletedSecretPoller(Object.assign(Object.assign({ name, client: this.pollerClient }, options), { requestOptions }));
            // This will initialize the poller's operation (the recovery of the deleted secret).
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Requests that a backup of the specified secret be downloaded to the client. All versions of the
     * secret will be downloaded. This operation requires the secrets/backup permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * let backupResult = await client.backupSecret("MySecretName");
     * ```
     * @summary Backs up the specified secret.
     * @param {string} secretName The name of the secret.
     * @param {BackupSecretOptions} [options] The optional parameters.
     */
    backupSecret(secretName, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestOptions = operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("backupSecret", requestOptions);
            let response;
            try {
                response = yield this.client.backupSecret(this.vaultUrl, secretName, this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return response.value;
        });
    }
    /**
     * Restores a backed up secret, and all its versions, to a vault. This operation requires the
     * secrets/restore permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * let mySecretBundle = await client.backupSecret("MySecretName");
     * // ...
     * await client.restoreSecretBackup(mySecretBundle);
     * ```
     * @summary Restores a backed up secret to a vault.
     * @param {Uint8Array} secretBundleBackup The backup blob associated with a secret bundle.
     * @param {RestoreSecretResponse} [options] The optional parameters.
     */
    restoreSecretBackup(secretBundleBackup, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestOptions = operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("restoreSecretBackup", requestOptions);
            let response;
            try {
                response = yield this.client.restoreSecret(this.vaultUrl, secretBundleBackup, this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return this.getSecretFromSecretBundle(response).properties;
        });
    }
    /**
     * @internal
     * @ignore
     * Sends a delete request for the given KeyVault Secret's name to the KeyVault service.
     * Since the KeyVault Secret won't be immediately deleted, we have {@link beginDeleteSecret}.
     * @param {string} name The name of the KeyVault Secret.
     * @param {RequestOptionsBase} [options] Optional parameters for the underlying HTTP request.
     */
    deleteSecret(secretName, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestOptions = operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("deleteSecret", requestOptions);
            let response;
            try {
                response = yield this.client.deleteSecret(this.vaultUrl, secretName, this.setParentSpan(span, requestOptions));
            }
            finally {
                span.end();
            }
            return this.getSecretFromSecretBundle(response);
        });
    }
    /**
     * @internal
     * @ignore
     * Sends a request to recover a deleted KeyVault Secret based on the given name.
     * Since the KeyVault Secret won't be immediately recover the deleted secret, we have {@link beginRecoverDeletedSecret}.
     * @param {string} name The name of the KeyVault Secret.
     * @param {RecoverDeletedKeyOptions} [options] Optional parameters for the underlying HTTP request.
     */
    recoverDeletedSecret(secretName, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestOptions = operationOptionsToRequestOptionsBase(options);
            const span = this.createSpan("recoverDeletedSecret", requestOptions);
            let properties;
            try {
                const response = yield this.client.recoverDeletedSecret(this.vaultUrl, secretName, this.setParentSpan(span, requestOptions));
                properties = this.getSecretFromSecretBundle(response).properties;
            }
            finally {
                span.end();
            }
            return properties;
        });
    }
    /**
     * @internal
     * @ignore
     * Deals with the pagination of {@link listPropertiesOfSecretVersions}.
     * @param {string} name The name of the KeyVault Secret.
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {ListPropertiesOfSecretVersionsOptions} [options] Optional parameters for the underlying HTTP request.
     */
    listPropertiesOfSecretVersionsPage(secretName, continuationState, options = {}) {
        return __asyncGenerator(this, arguments, function* listPropertiesOfSecretVersionsPage_1() {
            if (continuationState.continuationToken == null) {
                const optionsComplete = Object.assign({ maxresults: continuationState.maxPageSize }, options);
                const currentSetResponse = yield __await(this.client.getSecretVersions(this.vaultUrl, secretName, optionsComplete));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield __await(currentSetResponse.value.map((bundle) => this.getSecretFromSecretBundle(bundle).properties));
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield __await(this.client.getSecretVersions(continuationState.continuationToken, secretName, options));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield __await(currentSetResponse.value.map((bundle) => this.getSecretFromSecretBundle(bundle).properties));
                }
                else {
                    break;
                }
            }
        });
    }
    /**
     * @internal
     * @ignore
     * Deals with the iteration of all the available results of {@link listPropertiesOfSecretVersions}.
     * @param {string} name The name of the KeyVault Secret.
     * @param {ListPropertiesOfSecretVersionsOptions} [options] Optional parameters for the underlying HTTP request.
     */
    listPropertiesOfSecretVersionsAll(secretName, options = {}) {
        return __asyncGenerator(this, arguments, function* listPropertiesOfSecretVersionsAll_1() {
            var e_1, _a;
            const f = {};
            try {
                for (var _b = __asyncValues(this.listPropertiesOfSecretVersionsPage(secretName, f, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const item of page) {
                        yield yield __await(item);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Iterates all versions of the given secret in the vault. The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * for await (const secretProperties of client.listPropertiesOfSecretVersions("MySecretName")) {
     *   const secret = await client.getSecret(secretProperties.name);
     *   console.log("secret version: ", secret);
     * }
     * ```
     * @param {string} secretName Name of the secret to fetch versions for.
     * @param {ListPropertiesOfSecretVersionsOptions} [options] The optional parameters.
     */
    listPropertiesOfSecretVersions(secretName, options = {}) {
        const requestOptions = operationOptionsToRequestOptionsBase(options);
        const span = this.createSpan("listPropertiesOfSecretVersions", requestOptions);
        const updatedOptions = Object.assign(Object.assign({}, requestOptions), this.setParentSpan(span, requestOptions));
        const iter = this.listPropertiesOfSecretVersionsAll(secretName, updatedOptions);
        span.end();
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listPropertiesOfSecretVersionsPage(secretName, settings, updatedOptions)
        };
    }
    /**
     * @internal
     * @ignore
     * Deals with the pagination of {@link listPropertiesOfSecrets}.
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {ListPropertiesOfSecretsOptions} [options] Optional parameters for the underlying HTTP request.
     */
    listPropertiesOfSecretsPage(continuationState, options = {}) {
        return __asyncGenerator(this, arguments, function* listPropertiesOfSecretsPage_1() {
            if (continuationState.continuationToken == null) {
                const optionsComplete = Object.assign({ maxresults: continuationState.maxPageSize }, options);
                const currentSetResponse = yield __await(this.client.getSecrets(this.vaultUrl, optionsComplete));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield __await(currentSetResponse.value.map((bundle) => this.getSecretFromSecretBundle(bundle).properties));
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield __await(this.client.getSecrets(continuationState.continuationToken, options));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield __await(currentSetResponse.value.map((bundle) => this.getSecretFromSecretBundle(bundle).properties));
                }
                else {
                    break;
                }
            }
        });
    }
    /**
     * @internal
     * @ignore
     * Deals with the iteration of all the available results of {@link listPropertiesOfSecrets}.
     * @param {ListPropertiesOfSecretsOptions} [options] Optional parameters for the underlying HTTP request.
     */
    listPropertiesOfSecretsAll(options = {}) {
        return __asyncGenerator(this, arguments, function* listPropertiesOfSecretsAll_1() {
            var e_2, _a;
            const f = {};
            try {
                for (var _b = __asyncValues(this.listPropertiesOfSecretsPage(f, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const item of page) {
                        yield yield __await(item);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Iterates the latest version of all secrets in the vault.  The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * for await (const secretProperties of client.listPropertiesOfSecrets()) {
     *   const secret = await client.getSecret(secretProperties.name);
     *   console.log("secret: ", secret);
     * }
     * ```
     * @summary List all secrets in the vault.
     * @param {ListPropertiesOfSecretsOptions} [options] The optional parameters.
     */
    listPropertiesOfSecrets(options = {}) {
        const requestOptions = operationOptionsToRequestOptionsBase(options);
        const span = this.createSpan("listPropertiesOfSecrets", requestOptions);
        const updatedOptions = Object.assign(Object.assign({}, requestOptions), this.setParentSpan(span, requestOptions));
        const iter = this.listPropertiesOfSecretsAll(updatedOptions);
        span.end();
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listPropertiesOfSecretsPage(settings, updatedOptions)
        };
    }
    /**
     * @internal
     * @ignore
     * Deals with the pagination of {@link listDeletedSecrets}.
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {ListDeletedSecretsOptions} [options] Optional parameters for the underlying HTTP request.
     */
    listDeletedSecretsPage(continuationState, options = {}) {
        return __asyncGenerator(this, arguments, function* listDeletedSecretsPage_1() {
            if (continuationState.continuationToken == null) {
                const optionsComplete = Object.assign({ maxresults: continuationState.maxPageSize }, options);
                const currentSetResponse = yield __await(this.client.getDeletedSecrets(this.vaultUrl, optionsComplete));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield __await(currentSetResponse.value.map((bundle) => this.getSecretFromSecretBundle(bundle)));
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield __await(this.client.getDeletedSecrets(continuationState.continuationToken, options));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield __await(currentSetResponse.value.map((bundle) => this.getSecretFromSecretBundle(bundle)));
                }
                else {
                    break;
                }
            }
        });
    }
    /**
     * @internal
     * @ignore
     * Deals with the iteration of all the available results of {@link listDeletedSecrets}.
     * @param {ListDeletedSecretsOptions} [options] Optional parameters for the underlying HTTP request.
     */
    listDeletedSecretsAll(options = {}) {
        return __asyncGenerator(this, arguments, function* listDeletedSecretsAll_1() {
            var e_3, _a;
            const f = {};
            try {
                for (var _b = __asyncValues(this.listDeletedSecretsPage(f, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const item of page) {
                        yield yield __await(item);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Iterates the deleted secrets in the vault.  The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * for await (const deletedSecret of client.listDeletedSecrets()) {
     *   console.log("deleted secret: ", deletedSecret);
     * }
     * ```
     * @summary List all secrets in the vault.
     * @param {ListDeletedSecretsOptions} [options] The optional parameters.
     */
    listDeletedSecrets(options = {}) {
        const requestOptions = operationOptionsToRequestOptionsBase(options);
        const span = this.createSpan("listDeletedSecrets", requestOptions);
        const updatedOptions = Object.assign(Object.assign({}, requestOptions), this.setParentSpan(span, requestOptions));
        const iter = this.listDeletedSecretsAll(updatedOptions);
        span.end();
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listDeletedSecretsPage(settings, updatedOptions)
        };
    }
    /**
     * @internal
     * @ignore
     * Shapes the exposed {@link KeyVaultSecret} based on either a received secret bundle or deleted secret bundle.
     */
    getSecretFromSecretBundle(bundle) {
        const secretBundle = bundle;
        const deletedSecretBundle = bundle;
        const parsedId = parseKeyvaultEntityIdentifier("secrets", secretBundle.id);
        const attributes = secretBundle.attributes;
        delete secretBundle.attributes;
        const resultObject = {
            value: secretBundle.value,
            name: parsedId.name,
            properties: Object.assign(Object.assign(Object.assign({ expiresOn: attributes.expires, createdOn: attributes.created, updatedOn: attributes.updated }, secretBundle), parsedId), attributes)
        };
        if (deletedSecretBundle.deletedDate) {
            resultObject.properties.deletedOn = deletedSecretBundle.deletedDate;
            delete resultObject.properties.deletedDate;
        }
        if (attributes) {
            if (attributes.vaultUrl) {
                delete resultObject.properties.vaultUrl;
            }
            if (attributes.expires) {
                delete resultObject.properties.expires;
            }
            if (attributes.created) {
                delete resultObject.properties.created;
            }
            if (attributes.updated) {
                delete resultObject.properties.updated;
            }
        }
        return resultObject;
    }
    /**
     * @internal
     * @ignore
     * Creates a span using the tracer that was set by the user
     * @param {string} methodName The name of the method creating the span.
     * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.
     */
    createSpan(methodName, requestOptions = {}) {
        const tracer = getTracer();
        const span = tracer.startSpan(methodName, requestOptions && requestOptions.spanOptions);
        span.setAttribute("az.namespace", "Microsoft.KeyVault");
        return span;
    }
    /**
     * @internal
     * @ignore
     * Returns updated HTTP options with the given span as the parent of future spans,
     * if applicable.
     * @param {Span} span The span for the current operation.
     * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.
     */
    setParentSpan(span, options = {}) {
        if (span.isRecording()) {
            const spanOptions = options.spanOptions || {};
            return Object.assign(Object.assign({}, options), { spanOptions: Object.assign(Object.assign({}, spanOptions), { parent: span.context(), attributes: Object.assign(Object.assign({}, spanOptions.attributes), { "az.namespace": "Microsoft.KeyVault" }) }) });
        }
        else {
            return options;
        }
    }
}
//# sourceMappingURL=index.js.map